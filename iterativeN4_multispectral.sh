#!/bin/bash

# Created by argbash-init v2.8.0
# Rearrange the order of options below according to what you would like to see in the help message.
# ARG_OPTIONAL_SINGLE([exclude],[e],[Mask file defining regions to exclude from classifcation, region is still corrected])
# ARG_OPTIONAL_SINGLE([config],[c],[Path to an alternative config file defining priors to use])
# ARG_OPTIONAL_SINGLE([logfile],[l],[Path to file to log all output])
# ARG_OPTIONAL_BOOLEAN([standalone],[s],[Script is run standalone so save all outputs])
# ARG_OPTIONAL_BOOLEAN([autocrop],[a],[Crop the final output to 10 mm around the skull])
# ARG_OPTIONAL_BOOLEAN([denoise],[d],[Denoise the final output files])
# ARG_OPTIONAL_SINGLE([max-iterations],[],[Maximum number of iterations to run],[10])
# ARG_OPTIONAL_SINGLE([convergence-threshold],[],[Coeffcient of variation limit between two bias field estimates],[0.005])
# ARG_OPTIONAL_SINGLE([classification-prior-weight],[],[How much weight is given to prior classification proabilities during iteration],[0.25])
# ARG_OPTIONAL_BOOLEAN([debug],[],[Debug mode, increase verbosity further, don't cleanup])
# ARG_VERBOSE([v])
# ARG_POSITIONAL_SINGLE([input],[T1w scan to be corrected])
# ARG_POSITIONAL_SINGLE([output],[Output filename for corrected T1w (also used as basename for other outputs)])
# ARGBASH_SET_INDENT([  ])
# ARGBASH_SET_DELIM([ =])
# ARG_OPTION_STACKING([getopt])
# ARG_RESTRICT_VALUES([no-local-options])
# ARG_DEFAULTS_POS([])
# ARG_HELP([iterativeN4_multispectral.sh is script which performs iterative inhomogeneity (bias field) correction and classification on T1w (and optionally T2w/PDw) MRI scans])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.8.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
  local _ret=$2
  test -n "$_ret" || _ret=1
  test "$_PRINT_HELP" = yes && print_help >&2
  echo "$1" >&2
  exit ${_ret}
}


evaluate_strictness()
{
  [[ "$2" =~ ^-(-(exclude|config|logfile|standalone|autocrop|denoise|max-iterations|convergence-threshold|classification-prior-weight|debug|verbose|input|output|help)$|[eclsadvh]) ]] && die "You have passed '$2' as a value of argument '$1', which makes it look like that you have omitted the actual value, since '$2' is an option accepted by this script. This is considered a fatal error."
}


begins_with_short_option()
{
  local first_option all_short_options='eclsadvh'
  first_option="${1:0:1}"
  test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_input=
_arg_output=
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_exclude=
_arg_config=
_arg_logfile=
_arg_standalone="off"
_arg_autocrop="off"
_arg_denoise="off"
_arg_max_iterations="10"
_arg_convergence_threshold="0.005"
_arg_classification_prior_weight="0.25"
_arg_debug="off"
_arg_verbose=0


print_help()
{
  printf '%s\n' "iterativeN4_multispectral.sh is script which performs iterative inhomogeneity (bias field) correction and classification on T1w (and optionally T2w/PDw) MRI scans"
  printf 'Usage: %s [-e|--exclude <arg>] [-c|--config <arg>] [-l|--logfile <arg>] [-s|--(no-)standalone] [-a|--(no-)autocrop] [-d|--(no-)denoise] [--max-iterations <arg>] [--convergence-threshold <arg>] [--classification-prior-weight <arg>] [--(no-)debug] [-v|--verbose] [-h|--help] <input> <output>\n' "$0"
  printf '\t%s\n' "<input>: T1w scan to be corrected"
  printf '\t%s\n' "<output>: Output filename for corrected T1w (also used as basename for other outputs)"
  printf '\t%s\n' "-e, --exclude: Mask file defining regions to exclude from classifcation, region is still corrected (no default)"
  printf '\t%s\n' "-c, --config: Path to an alternative config file defining priors to use (no default)"
  printf '\t%s\n' "-l, --logfile: Path to file to log all output (no default)"
  printf '\t%s\n' "-s, --standalone, --no-standalone: Script is run standalone so save all outputs (off by default)"
  printf '\t%s\n' "-a, --autocrop, --no-autocrop: Crop the final output to 10 mm around the skull (off by default)"
  printf '\t%s\n' "-d, --denoise, --no-denoise: Denoise the final output files (off by default)"
  printf '\t%s\n' "--max-iterations: Maximum number of iterations to run (default: '10')"
  printf '\t%s\n' "--convergence-threshold: Coeffcient of variation limit between two bias field estimates (default: '0.005')"
  printf '\t%s\n' "--classification-prior-weight: How much weight is given to prior classification proabilities during iteration (default: '0.25')"
  printf '\t%s\n' "--debug, --no-debug: Debug mode, increase verbosity further, don't cleanup (off by default)"
  printf '\t%s\n' "-v, --verbose: Set verbose output (can be specified multiple times to increase the effect)"
  printf '\t%s\n' "-h, --help: Prints help"
}


parse_commandline()
{
  _positionals_count=0
  while test $# -gt 0
  do
    _key="$1"
    case "$_key" in
      -e|--exclude)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_exclude="$2"
        shift
        evaluate_strictness "$_key" "$_arg_exclude"
        ;;
      --exclude=*)
        _arg_exclude="${_key##--exclude=}"
        evaluate_strictness "$_key" "$_arg_exclude"
        ;;
      -e*)
        _arg_exclude="${_key##-e}"
        evaluate_strictness "$_key" "$_arg_exclude"
        ;;
      -c|--config)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_config="$2"
        shift
        evaluate_strictness "$_key" "$_arg_config"
        ;;
      --config=*)
        _arg_config="${_key##--config=}"
        evaluate_strictness "$_key" "$_arg_config"
        ;;
      -c*)
        _arg_config="${_key##-c}"
        evaluate_strictness "$_key" "$_arg_config"
        ;;
      -l|--logfile)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_logfile="$2"
        shift
        evaluate_strictness "$_key" "$_arg_logfile"
        ;;
      --logfile=*)
        _arg_logfile="${_key##--logfile=}"
        evaluate_strictness "$_key" "$_arg_logfile"
        ;;
      -l*)
        _arg_logfile="${_key##-l}"
        evaluate_strictness "$_key" "$_arg_logfile"
        ;;
      -s|--no-standalone|--standalone)
        _arg_standalone="on"
        test "${1:0:5}" = "--no-" && _arg_standalone="off"
        ;;
      -s*)
        _arg_standalone="on"
        _next="${_key##-s}"
        if test -n "$_next" -a "$_next" != "$_key"
        then
          { begins_with_short_option "$_next" && shift && set -- "-s" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      -a|--no-autocrop|--autocrop)
        _arg_autocrop="on"
        test "${1:0:5}" = "--no-" && _arg_autocrop="off"
        ;;
      -a*)
        _arg_autocrop="on"
        _next="${_key##-a}"
        if test -n "$_next" -a "$_next" != "$_key"
        then
          { begins_with_short_option "$_next" && shift && set -- "-a" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      -d|--no-denoise|--denoise)
        _arg_denoise="on"
        test "${1:0:5}" = "--no-" && _arg_denoise="off"
        ;;
      -d*)
        _arg_denoise="on"
        _next="${_key##-d}"
        if test -n "$_next" -a "$_next" != "$_key"
        then
          { begins_with_short_option "$_next" && shift && set -- "-d" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      --max-iterations)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_max_iterations="$2"
        shift
        evaluate_strictness "$_key" "$_arg_max_iterations"
        ;;
      --max-iterations=*)
        _arg_max_iterations="${_key##--max-iterations=}"
        evaluate_strictness "$_key" "$_arg_max_iterations"
        ;;
      --convergence-threshold)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_convergence_threshold="$2"
        shift
        evaluate_strictness "$_key" "$_arg_convergence_threshold"
        ;;
      --convergence-threshold=*)
        _arg_convergence_threshold="${_key##--convergence-threshold=}"
        evaluate_strictness "$_key" "$_arg_convergence_threshold"
        ;;
      --classification-prior-weight)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_classification_prior_weight="$2"
        shift
        evaluate_strictness "$_key" "$_arg_classification_prior_weight"
        ;;
      --classification-prior-weight=*)
        _arg_classification_prior_weight="${_key##--classification-prior-weight=}"
        evaluate_strictness "$_key" "$_arg_classification_prior_weight"
        ;;
      --no-debug|--debug)
        _arg_debug="on"
        test "${1:0:5}" = "--no-" && _arg_debug="off"
        ;;
      -v|--verbose)
        _arg_verbose=$((_arg_verbose + 1))
        ;;
      -v*)
        _arg_verbose=$((_arg_verbose + 1))
        _next="${_key##-v}"
        if test -n "$_next" -a "$_next" != "$_key"
        then
          { begins_with_short_option "$_next" && shift && set -- "-v" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      -h|--help)
        print_help
        exit 0
        ;;
      -h*)
        print_help
        exit 0
        ;;
      *)
        _last_positional="$1"
        _positionals+=("$_last_positional")
        _positionals_count=$((_positionals_count + 1))
        ;;
    esac
    shift
  done
}


handle_passed_args_count()
{
  local _required_args_string="'input' and 'output'"
  test "${_positionals_count}" -ge 2 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 2 (namely: $_required_args_string), but got only ${_positionals_count}." 1
  test "${_positionals_count}" -le 2 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
  local _positional_name _shift_for=$1
  _positional_names="_arg_input _arg_output "

  shift "$_shift_for"
  for _positional_name in ${_positional_names}
  do
    test $# -gt 0 || break
    eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
    shift
  done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

set -euoE pipefail

#Special trick to redirect all output within script into logfile
if [[ -n ${_arg_logfile} ]]; then
  exec >  >(tee -ia ${_arg_logfile})
  exec 2> >(tee -ia ${_arg_logfile} >&2)
fi

#If debug, print timestamps and every command run
if [[ ${_arg_debug} == "on" ]]; then
  set -xT
  set -o functrace
  PS4='+\t '
fi

#If verbose (or debug) turn on verbose outputs for commands
if [[ ${_arg_verbose} -ge 1 || ${_arg_debug} == "on" ]]; then
  N4_VERBOSE=1
fi

#Create temporary directory for work
tmpdir=$(mktemp -d)

#Setup exit trap for cleanup, don't do if debug
function finish {
  if [[ ${_arg_debug} == "off" ]]; then
    rm -rf "${tmpdir}"
  fi

}
trap finish EXIT

failure() {
  local lineno=$1
  local msg=$2
  echo "Failed at $lineno: $msg"
}
trap 'failure ${LINENO} "$BASH_COMMAND"' ERR

#Set local parallelism inherited from QBATCH
export ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS=${THREADS_PER_COMMAND:-$(nproc)}
export OMP_NUM_THREADS=${ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS}
export ITK_USE_THREADPOOL=1
export ITK_GLOBAL_DEFAULT_THREADER=Pool

### DEFAULT PRIORS ###

#BeAST configuration
BEASTLIBRARY_DIR="${QUARANTINE_PATH}/resources/BEaST_libraries/combined"
BEAST_CONFIG=${BEASTLIBRARY_DIR}/default.2mm.conf
BEAST_CONFIG2=${BEASTLIBRARY_DIR}/default.1mm.conf

#mni_icbm152_nlin_sym_09c priors as default
REGISTRATIONMODEL="${QUARANTINE_PATH}/resources/mni_icbm152_nlin_sym_09c_minc2/mni_icbm152_t1_tal_nlin_sym_09c.mnc"
REGISTRATIONBRAINMASK="${QUARANTINE_PATH}/resources/mni_icbm152_nlin_sym_09c_minc2/mni_icbm152_t1_tal_nlin_sym_09c_mask.mnc"
WMPRIOR="${QUARANTINE_PATH}/resources/mni_icbm152_nlin_sym_09c_minc2/mni_icbm152_wm_tal_nlin_sym_09c.mnc"
GMPRIOR="${QUARANTINE_PATH}/resources/mni_icbm152_nlin_sym_09c_minc2/mni_icbm152_gm_tal_nlin_sym_09c.mnc"
CSFPRIOR="${QUARANTINE_PATH}/resources/mni_icbm152_nlin_sym_09c_minc2/mni_icbm152_csf_tal_nlin_sym_09c.mnc"

#Files used to define MNI space
RESAMPLEMODEL="${QUARANTINE_PATH}/resources/mni_icbm152_nlin_sym_09c_minc2/mni_icbm152_t1_tal_nlin_sym_09c.mnc"
RESAMPLEMODELBRAINMASK="${QUARANTINE_PATH}/resources/mni_icbm152_nlin_sym_09c_minc2/mni_icbm152_t1_tal_nlin_sym_09c_mask.mnc"

# Check config files, eventually argbash will do this
if [[ -n ${_arg_config} ]]; then
  if [[ -r ${_arg_config} ]]; then
    source ${_arg_config}
  else
    echo "iterativeN4_multispectral.sh ERROR: config file does not exist or is not readable" && exit 2
  fi
fi

if [[ ! -d ${BEASTLIBRARY_DIR} ]]; then
  echo "iterativeN4_multispectral.sh ERROR: ${BEASTLIBRARY_DIR} does not exist"
fi

for prior in ${REGISTRATIONMODEL} ${REGISTRATIONBRAINMASK} ${WMPRIOR} ${GMPRIOR} ${CSFPRIOR} ${RESAMPLEMODEL} ${RESAMPLEMODELBRAINMASK} ${BEAST_CONFIG}; do
  if [[ ! -s ${prior} ]]; then
    echo "iterativeN4_multispectral.sh ERROR: File ${prior} does not exist or is zero size" && exit 3
  fi
done

#Setup internal variables
output=${_arg_output}
originput=${_arg_input}

#Internal resampled input used for processing
input=${tmpdir}/t1.mnc

#Quick awk math function
calc(){ awk "BEGIN { print "$*" }"; }

#Function for generating an outlier mask based on >3xIQR
#Mostly for excluding blood vessels when T1 was tuned improperly
function outlier_mask {
  #Generate an outlier mask as median+3*IQR
  local outlier_input=$1
  local outlier_mask=$2
  local outlier_output=$3

  local median
  local pct25
  local pct75
  local threshold

  ImageMath 3 ${tmpdir}/${n}/outlier_mask.mnc GetLargestComponent ${outlier_mask}
  median=$(mincstats -quiet -median -mask ${tmpdir}/${n}/outlier_mask.mnc -mask_binvalue 1 ${outlier_input})
  pct25=$(mincstats -quiet -pctT 25 -hist_bins 10000 -mask ${tmpdir}/${n}/outlier_mask.mnc -mask_binvalue 1 ${outlier_input})
  pct75=$(mincstats -quiet -pctT 75 -hist_bins 10000 -mask ${tmpdir}/${n}/outlier_mask.mnc -mask_binvalue 1 ${outlier_input})
  threshold=$(calc "${median}+3*(${pct75}-${pct25})")

  minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -unsigned -byte -expression "A[0]>${threshold}?1:0" ${outlier_input} ${outlier_output}
  mincdefrag ${outlier_output} $(dirname ${outlier_output})/$(basename ${outlier_output} .mnc).defrag.mnc 1 6 1
  minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -unsigned -byte -expression "A[0]?0:1" $(dirname ${outlier_output})/$(basename ${outlier_output} .mnc).defrag.mnc ${outlier_output}
}

#Function used to do bias field correction
function do_N4_correct {
  #input fov mask weight output bias shrink
  local n4input=$1
  local n4initmask=$2
  local n4brainmask=$3
  local n4weight=$4
  local n4corrected=$5
  local n4bias=$6
  local n4shrink=$7

  local min
  local max
  local pct25
  local pct75
  local npoints
  local histbins

  #Calculate bins for N4 with Freedman-Diaconis’s Rule
  min=$(mincstats -quiet -min -mask ${n4weight} -mask_range 1e-9,inf ${n4input})
  max=$(mincstats -quiet -max -mask ${n4weight} -mask_range 1e-9,inf ${n4input})
  npoints=$(mincstats -quiet -count -mask ${n4weight} -mask_range 1e-9,inf ${n4input})
  pct25=$(mincstats -quiet -pctT 25 -hist_bins 10000 -mask ${n4weight} -mask_range 1e-9,inf ${n4input})
  pct75=$(mincstats -quiet -pctT 75 -hist_bins 10000 -mask ${n4weight} -mask_range 1e-9,inf ${n4input})
  histbins=$(python -c "print( int((float(${max})-float(${min}))/(2.0 * (float(${pct75})-float(${pct25})) * float(${npoints})**(-1.0/3.0)) ))" )

  N4BiasFieldCorrection ${N4_VERBOSE:+--verbose} -d 3 -s ${n4shrink} -w ${n4weight} -x ${n4initmask} \
    -b [200] -c [300x300x300x300,1e-5] --histogram-sharpening [0.05,0.01,${histbins}] \
    -i ${n4input} \
    -o [${n4corrected},${n4bias}] -r 0

  #Demean bias field estimate and recorrect file
  ImageMath 3 ${n4bias} / ${n4bias} $(mincstats -quiet -mean ${n4bias})
  if (( n == 0 )); then
    ImageMath 3 ${n4corrected} / ${n4input} ${n4bias}
  elif (( n == 1 )); then
    AverageImages 3 ${tmpdir}/${n}/avg_bias.mnc 0 ${n4bias} ${tmpdir}/$((n - 1))/bias.mnc
    ImageMath 3 ${n4corrected} / ${n4input} ${tmpdir}/${n}/avg_bias.mnc
  else
    AverageImages 3 ${tmpdir}/${n}/avg_bias.mnc 0 ${n4bias} ${tmpdir}/$((n - 1))/avg_bias.mnc
    ImageMath 3 ${n4corrected} / ${n4input} ${tmpdir}/${n}/avg_bias.mnc
  fi

  #Normalize and rescale intensity
  ImageMath 3 ${n4corrected} TruncateImageIntensity ${n4corrected} 0.0005 0.9995 1024 ${n4brainmask}
  ImageMath 3 ${n4corrected} RescaleImage ${n4corrected} 0 ${maxval}
}

#Convert classify image into a mask
function classify_to_mask {
  #Breakup classification and drop try to exclude small misclassified chunks
  ThresholdImage 3 ${tmpdir}/${n}/classify.mnc ${tmpdir}/${n}/class3.mnc 3 3 1 0
  ThresholdImage 3 ${tmpdir}/${n}/classify.mnc ${tmpdir}/${n}/class2.mnc 2 2 1 0
  ThresholdImage 3 ${tmpdir}/${n}/classify.mnc ${tmpdir}/${n}/class1.mnc 1 1 1 0
  #Get largest component
  ImageMath 3 ${tmpdir}/${n}/class3.mnc GetLargestComponent ${tmpdir}/${n}/class3.mnc
  ImageMath 3 ${tmpdir}/${n}/class2.mnc GetLargestComponent ${tmpdir}/${n}/class2.mnc

  #Fill holes in GM
  ImageMath 3 ${tmpdir}/${n}/class2.mnc FillHoles ${tmpdir}/${n}/class2.mnc 2

  #Erode CSF to just get any minimal ventical voxels
  ImageMath 3 ${tmpdir}/${n}/class1.mnc ME ${tmpdir}/${n}/class1.mnc 10

  #ImageMath 3 ${tmpdir}/${n}/classifymask.mnc addtozero ${tmpdir}/bmask.mnc ${tmpdir}/mnimask.mnc
  cp -f ${tmpdir}/bmask.mnc ${tmpdir}/${n}/classifymask.mnc

  mincmath -quiet ${N4_VERBOSE:+-verbose} -unsigned -byte -labels -or ${tmpdir}/${n}/class2.mnc ${tmpdir}/${n}/class3.mnc ${tmpdir}/${n}/class1.mnc \
    ${tmpdir}/${n}/classifymask.mnc ${tmpdir}/${n}/classifymask2.mnc
  mv -f ${tmpdir}/${n}/classifymask2.mnc ${tmpdir}/${n}/classifymask.mnc

  ImageMath 3 ${tmpdir}/${n}/classifymask.mnc ME ${tmpdir}/${n}/classifymask.mnc 2
  ImageMath 3 ${tmpdir}/${n}/classifymask.mnc GetLargestComponent ${tmpdir}/${n}/classifymask.mnc
  ImageMath 3 ${tmpdir}/${n}/classifymask.mnc MD ${tmpdir}/${n}/classifymask.mnc 4
  ImageMath 3 ${tmpdir}/${n}/classifymask.mnc FillHoles ${tmpdir}/${n}/classifymask.mnc 2
  ThresholdImage 3 ${tmpdir}/${n}/classify.mnc ${tmpdir}/${n}/class3.mnc 3 3 1 0
}

#Find maximum value of scan to rescale to for final output
maxval=$(mincstats -pctT 99.99 -quiet ${originput})

#Forceably convert to MINC2, and clamp range to avoid negative numbers
mincconvert -2 ${originput} ${tmpdir}/originput.mnc
mincmath -quiet ${N4_VERBOSE:+-verbose} -clamp -const2 0 ${maxval} ${tmpdir}/originput.mnc ${tmpdir}/originput.clamp.mnc
mv -f ${tmpdir}/originput.clamp.mnc ${tmpdir}/originput.mnc
originput=${tmpdir}/originput.mnc

#Isotropize, crop, clamp, and pad input volume
isostep=1
ResampleImage 3 ${originput} ${input} ${isostep}x${isostep}x${isostep} 0 4
mincmath -quiet ${N4_VERBOSE:+-verbose} -clamp -const2 0 ${maxval} ${input} ${tmpdir}/input.clamp.mnc
mv -f ${tmpdir}/input.clamp.mnc ${input}

#If lesion mask exists, negate it to produce a multiplicative exlcusion mask, resample to internal resolution
if [[ -n ${_arg_exclude} ]]; then
  ImageMath 3 ${tmpdir}/exclude.mnc Neg ${_arg_exclude}
  excludemask=${tmpdir}/exclude.mnc
  antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -i ${excludemask} -r ${input} -n GenericLabel -o ${excludemask}
else
  excludemask=""
fi

#Compute final round shink factor for N4 to always be the same resolution
dx=$(mincinfo -attvalue xspace:step ${originput})
dy=$(mincinfo -attvalue yspace:step ${originput})
dz=$(mincinfo -attvalue zspace:step ${originput})
shrink_final_round=$(python -c "import math; print(max(2,int(math.floor(2.0 / ( ( abs($dx) + abs($dy) + abs($dz) ) / 3.0)))))")

################################################################################
#Round 0, N4 across areas greater than 0.5% of mean
################################################################################
n=0

mkdir -p ${tmpdir}/${n}

minc_anlm ${N4_VERBOSE:+--verbose} --rician --mt ${ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS} ${input} ${tmpdir}/${n}/t1.mnc

#First try registration to MNI space to get headmask
antsRegistration ${N4_VERBOSE:+--verbose} -d 3 --float 1 --minc \
  --output [${tmpdir}/${n}/mni] \
  --use-histogram-matching 0 \
  --initial-moving-transform [${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1] \
  --transform Translation[0.5] \
    --metric Mattes[${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1,32,Regular,0.25] \
    --convergence [2025x2025x2025x2025x2025x2025,1e-6,10] \
    --shrink-factors 16x15x14x13x12x11 \
    --smoothing-sigmas 13.5891488046x12.7398270043x11.890505204x11.0411834037x10.1918616035x9.34253980317mm \
  --transform Rigid[0.25] \
    --metric Mattes[${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1,37,Regular,0.25] \
    --convergence [2025x2025x2025x2025x2025x2025,1e-6,10] \
    --shrink-factors 13x12x11x10x9x8 \
    --smoothing-sigmas 11.0411834037x10.1918616035x9.34253980317x8.49321800288x7.64389620259x6.7945744023mm \
  --transform Similarity[0.125] \
    --metric Mattes[${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1,64,Regular,0.25] \
    --convergence [2025x2025x2025x2025x2025x2025,1e-6,10] \
    --shrink-factors 10x9x8x7x6x5 \
    --smoothing-sigmas 8.49321800288x7.64389620259x6.7945744023x5.94525260202x5.09593080173x4.24660900144mm \
  --transform Affine[0.1] \
    --metric Mattes[${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1,256,Regular,0.25] \
    --convergence [2025x2025x2025x2025x2025x2025,1e-6,10] \
    --shrink-factors 7x6x5x4x3x2 \
    --smoothing-sigmas 5.94525260202x5.09593080173x4.24660900144x3.39728720115x2.54796540086x1.69864360058mm \

#Generate model headmask
ImageMath 3 ${tmpdir}/modelheadmask.mnc ThresholdAtMean ${REGISTRATIONMODEL} 0.5
ImageMath 3 ${tmpdir}/modelheadmask.mnc FillHoles ${tmpdir}/modelheadmask.mnc 2

#Resample into subject space, zero background and recrop
ImageMath 3 ${input} PadImage ${input} 50
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -i ${tmpdir}/modelheadmask.mnc -t [${tmpdir}/${n}/mni0_GenericAffine.xfm,1] -o ${tmpdir}/headmask.mnc -r ${input} -n GenericLabel
ImageMath 3 ${input} m ${input} ${tmpdir}/headmask.mnc
ExtractRegionFromImageByMask 3 ${input} ${tmpdir}/input.crop.mnc ${tmpdir}/headmask.mnc 1 10
mv -f ${tmpdir}/input.crop.mnc ${input}

#Zero and recrop the input file as well for stages going forward
ImageMath 3 ${tmpdir}/${n}/t1.mnc PadImage ${tmpdir}/${n}/t1.mnc 50
ImageMath 3 ${tmpdir}/${n}/t1.mnc m ${tmpdir}/${n}/t1.mnc ${tmpdir}/headmask.mnc
ExtractRegionFromImageByMask 3 ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/t1.crop.mnc ${tmpdir}/headmask.mnc 1 10
mv -f ${tmpdir}/${n}/t1.crop.mnc ${tmpdir}/${n}/t1.mnc

#Initial threshold of greater than 0.5 of mean intensity
ImageMath 3 ${tmpdir}/${n}/weight.mnc ThresholdAtMean ${tmpdir}/${n}/t1.mnc 0.5

#Use exclude mask if provided
if [[ -n ${excludemask} ]]; then
  ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${excludemask}
fi

#Generate a whole-image mask to force N4 to always do correction over whole image
minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -unsigned -byte -expression '1' ${input} ${tmpdir}/initmask.mnc

#Always exclude 0 from correction
minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -unsigned -byte -expression 'A[0]>0?1:0' ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/nonzero.mnc
ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/nonzero.mnc

do_N4_correct ${input} ${tmpdir}/initmask.mnc ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/corrected.mnc ${tmpdir}/${n}/bias.mnc 4

################################################################################
#Round 1, N4 across areas greater than 0.5% of mean, intersected with affine brainmask
################################################################################
((++n))
mkdir -p ${tmpdir}/${n}

minc_anlm ${N4_VERBOSE:+--verbose} --rician --mt ${ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS} ${tmpdir}/$((n - 1))/corrected.mnc ${tmpdir}/${n}/t1.mnc

#First try registration to MNI space, multistep
antsRegistration ${N4_VERBOSE:+--verbose} -d 3 --float 1 --minc \
  --output [${tmpdir}/${n}/mni] \
  --use-histogram-matching 0 \
  --initial-moving-transform ${tmpdir}/$((n - 1))/mni0_GenericAffine.xfm \
  --transform Affine[0.1] \
    --metric Mattes[${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1,256,Regular,0.5] \
    --convergence [2025x2025x2025x2025x2025x2025,1e-6,10] \
    --shrink-factors 7x6x5x4x3x2 \
    --smoothing-sigmas 5.94525260202x5.09593080173x4.24660900144x3.39728720115x2.54796540086x1.69864360058mm \
    --masks [NULL,NULL] \
  --transform Affine[0.1] \
    --metric Mattes[${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1,256,None] \
    --convergence [2025x2025x2025x750x250,1e-6,20] \
    --shrink-factors 4x3x2x1x1 \
    --smoothing-sigmas 3.39728720115x2.54796540086x1.69864360058x0.849321800288x0mm \
    --masks [${REGISTRATIONBRAINMASK},NULL]

antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -r ${tmpdir}/${n}/t1.mnc -t [${tmpdir}/${n}/mni0_GenericAffine.xfm,1] -i ${REGISTRATIONBRAINMASK} -o ${tmpdir}/${n}/mnimask.mnc -n GenericLabel

#Generate a hotmask using the existing weight mask
outlier_mask ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/mnimask.mnc ${tmpdir}/${n}/hotmask.mnc
ImageMath 3 ${tmpdir}/${n}/kmeansmask.mnc m ${tmpdir}/${n}/mnimask.mnc ${tmpdir}/${n}/hotmask.mnc

#Do a quick kmeans to get gm/wm and make a hard mask for weight
ThresholdImage 3 ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/weight.mnc Kmeans 2 ${tmpdir}/${n}/kmeansmask.mnc
ThresholdImage 3 ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/weight.mnc 2 3 1 0
iMath 3 ${tmpdir}/${n}/weight.mnc ME ${tmpdir}/${n}/weight.mnc 1 1 ball 1
ImageMath 3 ${tmpdir}/${n}/weight.mnc GetLargestComponent ${tmpdir}/${n}/weight.mnc
iMath 3 ${tmpdir}/${n}/weight.mnc MD ${tmpdir}/${n}/weight.mnc 1 1 ball 1

#User provided exclusion mask
if [[ -n ${excludemask} ]]; then
  ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${excludemask}
fi

#Remove outliers
ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/hotmask.mnc
ImageMath 3 ${tmpdir}/${n}/weight.mnc GetLargestComponent ${tmpdir}/${n}/weight.mnc

#Always exclude 0 from correction
minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -unsigned -byte -expression 'A[0]>0?1:0' ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/nonzero.mnc
ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/nonzero.mnc

do_N4_correct ${input} ${tmpdir}/initmask.mnc ${tmpdir}/${n}/mnimask.mnc ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/corrected.mnc ${tmpdir}/${n}/bias.mnc 4

#Calculate coeffcient of variation between this round bias field and prior round
minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -zero -expression 'A[0]/A[1]' ${tmpdir}/$((n - 1))/bias.mnc ${tmpdir}/${n}/bias.mnc ${tmpdir}/${n}/ratio.mnc
python -c "print(float(\"$(mincstats -quiet -stddev ${tmpdir}/${n}/ratio.mnc)\") / float(\"$(mincstats -quiet -mean ${tmpdir}/${n}/ratio.mnc)\"))" >>${tmpdir}/convergence.txt

if [[ ${_arg_debug} == "off" ]]; then
  rm -rf ${tmpdir}/$((n - 1))
fi

################################################################################
#Round 2, N4 with brain mask intersected with Otsu mask
################################################################################
((++n))
mkdir -p ${tmpdir}/${n}

minc_anlm ${N4_VERBOSE:+--verbose} --rician --mt ${ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS} ${tmpdir}/$((n - 1))/corrected.mnc ${tmpdir}/${n}/t1.mnc

#Register to MNI space
antsRegistration ${N4_VERBOSE:+--verbose} -d 3 --float 1 --minc \
  --output [${tmpdir}/${n}/mni] \
  --use-histogram-matching 0 \
  --initial-moving-transform ${tmpdir}/$((n - 1))/mni0_GenericAffine.xfm \
  --transform Affine[0.1] \
    --metric Mattes[${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1,256,None] \
    --convergence [2025x2025x2025x750x250,1e-6,20] \
    --shrink-factors 4x3x2x1x1 \
    --smoothing-sigmas 3.39728720115x2.54796540086x1.69864360058x0.849321800288x0mm \
    --masks [${REGISTRATIONBRAINMASK},NULL]

#Bring MNI mask to native space affinely
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -r ${tmpdir}/${n}/t1.mnc -t [${tmpdir}/${n}/mni0_GenericAffine.xfm,1] -i ${REGISTRATIONBRAINMASK} -o ${tmpdir}/${n}/mnimask.mnc -n GenericLabel

#Make MNI-space copy of brain for BeAST
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -i ${tmpdir}/${n}/t1.mnc -t ${tmpdir}/${n}/mni0_GenericAffine.xfm -n BSpline[5] -o ${tmpdir}/${n}/mni.mnc -r ${RESAMPLEMODEL}
#BSpline[5] does weird things to intensity, clip back to positive range
mincmath -quiet ${N4_VERBOSE:+-verbose} -clamp -const2 0 $(mincstats -quiet -max ${tmpdir}/${n}/mni.mnc) ${tmpdir}/${n}/mni.mnc ${tmpdir}/${n}/mni.clamp.mnc
mv -f ${tmpdir}/${n}/mni.clamp.mnc ${tmpdir}/${n}/mni.mnc

#Shrink the MNI mask for the first intensity matching
iMath 3 ${tmpdir}/${n}/shrinkmask.mnc ME ${RESAMPLEMODELBRAINMASK} 3 1 ball 1

#Intensity normalize
volume_pol --order 1 --min 0 --max 100 --noclamp ${tmpdir}/${n}/mni.mnc ${RESAMPLEMODEL} --source_mask ${tmpdir}/${n}/shrinkmask.mnc --target_mask ${RESAMPLEMODELBRAINMASK} ${tmpdir}/${n}/mni.norm.mnc

#Run a quick beast to get a brain mask
mincbeast ${N4_VERBOSE:+-verbose} -v2 -double -fill -median -same_res -flip -conf ${BEAST_CONFIG} ${BEASTLIBRARY_DIR} ${tmpdir}/${n}/mni.norm.mnc ${tmpdir}/${n}/beastmask.mnc

#Resample beast mask and MNI mask to native space
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -r ${tmpdir}/${n}/t1.mnc -t [${tmpdir}/${n}/mni0_GenericAffine.xfm,1] -i ${REGISTRATIONBRAINMASK} -o ${tmpdir}/${n}/mnimask.mnc -n GenericLabel
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -r ${tmpdir}/${n}/t1.mnc -t [${tmpdir}/${n}/mni0_GenericAffine.xfm,1] -i ${tmpdir}/${n}/beastmask.mnc -o ${tmpdir}/${n}/bmask.mnc -n GenericLabel

#Combine the masks because sometimes beast misses badly biased cerebellum
ImageMath 3 ${tmpdir}/${n}/mask.mnc addtozero ${tmpdir}/${n}/mnimask.mnc ${tmpdir}/${n}/bmask.mnc

#Generate a hotmask using the existing weight mask
outlier_mask ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/mask.mnc ${tmpdir}/${n}/hotmask.mnc
ImageMath 3 ${tmpdir}/${n}/kmeansmask.mnc m ${tmpdir}/${n}/mask.mnc ${tmpdir}/${n}/hotmask.mnc

#Do a quick kmeans to get gm/wm and make a hard mask for weight
ThresholdImage 3 ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/weight.mnc Kmeans 2 ${tmpdir}/${n}/kmeansmask.mnc
ThresholdImage 3 ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/weight.mnc 2 3 1 0
iMath 3 ${tmpdir}/${n}/weight.mnc ME ${tmpdir}/${n}/weight.mnc 1 1 ball 1
ImageMath 3 ${tmpdir}/${n}/weight.mnc GetLargestComponent ${tmpdir}/${n}/weight.mnc
iMath 3 ${tmpdir}/${n}/weight.mnc MD ${tmpdir}/${n}/weight.mnc 1 1 ball 1

if [[ -n ${excludemask} ]]; then
  ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${excludemask}
fi

#Generate a hotmask using the kmeans brainmask
outlier_mask ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/hotmask.mnc
#Remove really hot voxels from weight for N4
ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/hotmask.mnc
ImageMath 3 ${tmpdir}/${n}/weight.mnc GetLargestComponent ${tmpdir}/${n}/weight.mnc

#Always exclude 0 from correction
minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -unsigned -byte -expression 'A[0]>0?1:0' ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/nonzero.mnc
ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/nonzero.mnc

do_N4_correct ${input} ${tmpdir}/initmask.mnc ${tmpdir}/${n}/mask.mnc ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/corrected.mnc ${tmpdir}/${n}/bias.mnc 4

minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -zero -expression 'A[0]/A[1]' ${tmpdir}/$((n - 1))/bias.mnc ${tmpdir}/${n}/bias.mnc ${tmpdir}/${n}/ratio.mnc
python -c "print(float(\"$(mincstats -quiet -stddev ${tmpdir}/${n}/ratio.mnc)\") / float(\"$(mincstats -quiet -mean ${tmpdir}/${n}/ratio.mnc)\"))" >>${tmpdir}/convergence.txt

if [[ ${_arg_debug} == "off" ]]; then
  rm -rf ${tmpdir}/$((n - 1))
fi

################################################################################
#Round 3, N4 with nonlinearly MNI-bootstrapped WM/GM segmentation proabilities
################################################################################
((++n))
mkdir -p ${tmpdir}/${n}

minc_anlm ${N4_VERBOSE:+--verbose} --rician --mt ${ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS} ${tmpdir}/$((n - 1))/corrected.mnc ${tmpdir}/${n}/t1.mnc

#Affine register to MNI space, tweak registration
antsRegistration ${N4_VERBOSE:+--verbose} -d 3 --float 1 --minc \
  --output [${tmpdir}/${n}/mni] \
  --use-histogram-matching 0 \
  --initial-moving-transform ${tmpdir}/$((n - 1))/mni0_GenericAffine.xfm \
  --transform Affine[0.05] \
    --metric Mattes[${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1,256,None] \
    --convergence [2025x2025x2025x750x250,1e-6,20] \
    --shrink-factors 4x3x2x1x1 \
    --smoothing-sigmas 3.39728720115x2.54796540086x1.69864360058x0.849321800288x0mm \
    --masks [${REGISTRATIONBRAINMASK},${tmpdir}/$((n - 1))/mask.mnc]

antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -i ${tmpdir}/${n}/t1.mnc -t ${tmpdir}/${n}/mni0_GenericAffine.xfm -n BSpline[5] -o ${tmpdir}/${n}/mni.mnc -r ${RESAMPLEMODEL}
mincmath -quiet ${N4_VERBOSE:+-verbose}  -clamp -const2 0 $(mincstats -quiet -max ${tmpdir}/${n}/mni.mnc) ${tmpdir}/${n}/mni.mnc ${tmpdir}/${n}/mni.clamp.mnc
mv -f ${tmpdir}/${n}/mni.clamp.mnc ${tmpdir}/${n}/mni.mnc

#Shrink last round's beastmask for normalization
iMath 3 ${tmpdir}/${n}/shrinkmask.mnc ME ${tmpdir}/$((n - 1))/beastmask.mnc 3 1 ball 1

#Intensity normalize
volume_pol --order 1 --min 0 --max 100 --noclamp ${tmpdir}/${n}/mni.mnc ${RESAMPLEMODEL} --source_mask ${tmpdir}/${n}/shrinkmask.mnc --target_mask ${RESAMPLEMODELBRAINMASK} ${tmpdir}/${n}/mni.norm.mnc

#Run a quick beast to get a brain mask
mincbeast ${N4_VERBOSE:+-verbose} -v2 -double -fill -median -same_res -flip -conf ${BEAST_CONFIG2} ${BEASTLIBRARY_DIR} ${tmpdir}/${n}/mni.norm.mnc ${tmpdir}/${n}/beastmask.mnc

antsApplyTransforms -i ${tmpdir}/${n}/beastmask.mnc -t [${tmpdir}/${n}/mni0_GenericAffine.xfm,1] -r ${tmpdir}/${n}/t1.mnc -o ${tmpdir}/${n}/bmask.mnc ${N4_VERBOSE:+--verbose} -d 3 -n GenericLabel
antsApplyTransforms -i ${REGISTRATIONBRAINMASK} -t [${tmpdir}/${n}/mni0_GenericAffine.xfm,1] -r ${tmpdir}/${n}/t1.mnc -o ${tmpdir}/${n}/mniaffinemask.mnc ${N4_VERBOSE:+--verbose} -d 3 -n GenericLabel

#Last time beast is run, copy outside loops
cp -f ${tmpdir}/${n}/bmask.mnc ${tmpdir}/bmask.mnc

#Create extracted model for nonlinear registration
iMath 3 ${tmpdir}/${n}/extractmask.mnc MD ${tmpdir}/${n}/bmask.mnc 3 1 ball 1
iMath 3 ${tmpdir}/${n}/modelextractmask.mnc MD ${REGISTRATIONBRAINMASK} 3 1 ball 1

#Extract t1
minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -expression 'A[0]*A[1]' ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/extractmask.mnc ${tmpdir}/${n}/t1.extracted.mnc
minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -expression 'A[0]*A[1]' ${REGISTRATIONMODEL} ${tmpdir}/${n}/modelextractmask.mnc ${tmpdir}/${n}/modelextracted.mnc

#Non linearly register priors
antsRegistration ${N4_VERBOSE:+--verbose} -d 3 --float 1 --minc \
  --output [${tmpdir}/${n}/nonlin] \
  --initial-moving-transform ${tmpdir}/${n}/mni0_GenericAffine.xfm \
  --use-histogram-matching 0 \
  --transform SyN[0.1,3,0] \
    --metric Mattes[${tmpdir}/${n}/modelextracted.mnc,${tmpdir}/${n}/t1.extracted.mnc,1,256,None] \
    --convergence [2025x2025x2025x2025x2025x2025x2025x2025x2025x2025x1600x800x400x200x100x100x100,1e-7,10] \
    --shrink-factors 6x6x6x6x6x6x6x6x6x6x6x5x4x3x2x1x1 \
    --smoothing-sigmas 13.5891488046x12.7398270043x11.890505204x11.0411834037x10.1918616035x9.34253980317x8.49321800288x7.64389620259x6.7945744023x5.94525260202x5.09593080173x4.24660900144x3.39728720115x2.54796540086x1.69864360058x0.849321800288x0mm

#Resample MNI Priors to Native space for classification
antsApplyTransforms -i ${WMPRIOR} -t [${tmpdir}/${n}/mni0_GenericAffine.xfm,1] -t ${tmpdir}/${n}/nonlin1_inverse_NL.xfm -r ${tmpdir}/${n}/t1.mnc -o ${tmpdir}/${n}/SegmentationPrior3.mnc ${N4_VERBOSE:+--verbose} -d 3 -n Linear
antsApplyTransforms -i ${GMPRIOR} -t [${tmpdir}/${n}/mni0_GenericAffine.xfm,1] -t ${tmpdir}/${n}/nonlin1_inverse_NL.xfm -r ${tmpdir}/${n}/t1.mnc -o ${tmpdir}/${n}/SegmentationPrior2.mnc ${N4_VERBOSE:+--verbose} -d 3 -n Linear
antsApplyTransforms -i ${CSFPRIOR} -t [${tmpdir}/${n}/mni0_GenericAffine.xfm,1] -t ${tmpdir}/${n}/nonlin1_inverse_NL.xfm -r ${tmpdir}/${n}/t1.mnc -o ${tmpdir}/${n}/SegmentationPrior1.mnc ${N4_VERBOSE:+--verbose} -d 3 -n Linear
#Masks
antsApplyTransforms -i ${REGISTRATIONBRAINMASK} -t [${tmpdir}/${n}/mni0_GenericAffine.xfm,1] -t ${tmpdir}/${n}/nonlin1_inverse_NL.xfm -r ${tmpdir}/${n}/t1.mnc -o ${tmpdir}/${n}/mnimask.mnc ${N4_VERBOSE:+--verbose} -d 3 -n GenericLabel

#Last time we generate MNI mask, save it outside iterations
cp -f ${tmpdir}/${n}/mnimask.mnc ${tmpdir}/mnimask.mnc
cp -f ${tmpdir}/${n}/mniaffinemask.mnc ${tmpdir}/mniaffinemask.mnc

#Combine the masks because sometimes beast misses badly biased cerebellum
mincmath -quiet ${N4_VERBOSE:+-verbose} -unsigned -labels -byte -or ${tmpdir}/${n}/mnimask.mnc ${tmpdir}/${n}/bmask.mnc ${tmpdir}/${n}/mask.mnc

#Expand the mask a bit
iMath 3 ${tmpdir}/${n}/mask_D.mnc MD ${tmpdir}/${n}/mask.mnc 1 1 box 1

if [[ -n ${excludemask} ]]; then
  ImageMath 3 ${tmpdir}/${n}/mask_D.mnc m ${tmpdir}/${n}/mask_D.mnc ${excludemask}
fi

#Do an initial classification using the MNI priors
Atropos ${N4_VERBOSE:+--verbose} -d 3 -x ${tmpdir}/${n}/mask_D.mnc -c [25,0.001] -a ${tmpdir}/${n}/t1.mnc \
  -i PriorProbabilityImages[3,${tmpdir}/${n}/SegmentationPrior%d.mnc,${_arg_classification_prior_weight}] -k HistogramParzenWindows -m [0.1,1x1x1] \
  -o [${tmpdir}/${n}/classify.mnc,${tmpdir}/${n}/SegmentationPosteriors%d.mnc] -r 1 -p Aristotle[0] --winsorize-outliers BoxPlot \
  -l [0.69314718055994530942,1]

#Convert classification to the mask
classify_to_mask

#Generate outlier mask from white matter mask intensity
outlier_mask ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/class3.mnc ${tmpdir}/${n}/hotmask.mnc

#Combine GM and WM proabability images into a N4 mask,
ImageMath 3 ${tmpdir}/${n}/weight.mnc PureTissueN4WeightMask ${tmpdir}/${n}/SegmentationPosteriors2.mnc ${tmpdir}/${n}/SegmentationPosteriors3.mnc
ImageMath 3 ${tmpdir}/${n}/weight.mnc RescaleImage ${tmpdir}/${n}/weight.mnc 0 1

ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/hotmask.mnc

if [[ -n ${excludemask} ]]; then
  ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${excludemask}
fi

#Clip the classification outputs with the new mask
for item in ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/classify.mnc ${tmpdir}/${n}/SegmentationPosteriors1.mnc ${tmpdir}/${n}/SegmentationPosteriors2.mnc ${tmpdir}/${n}/SegmentationPosteriors3.mnc; do
  ImageMath 3 ${item} m ${item} ${tmpdir}/${n}/classifymask.mnc
  ImageMath 3 ${item} m ${item} ${tmpdir}/${n}/hotmask.mnc
done

#Always exclude 0 from correction
minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -unsigned -byte -expression 'A[0]>0?1:0' ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/nonzero.mnc
ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/nonzero.mnc

do_N4_correct ${input} ${tmpdir}/initmask.mnc ${tmpdir}/${n}/classifymask.mnc ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/corrected.mnc ${tmpdir}/${n}/bias.mnc 4

minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -zero -expression 'A[0]/A[1]' ${tmpdir}/$((n - 1))/bias.mnc ${tmpdir}/${n}/bias.mnc ${tmpdir}/${n}/ratio.mnc
python -c "print(float(\"$(mincstats -quiet -stddev ${tmpdir}/${n}/ratio.mnc)\") / float(\"$(mincstats -quiet -mean ${tmpdir}/${n}/ratio.mnc)\"))" >>${tmpdir}/convergence.txt

if [[ ${_arg_debug} == "off" ]]; then
  rm -rf ${tmpdir}/$((n - 1))
fi

################################################################################
#Remaining rounds, N4 with segmentations bootstrapped from prior run
################################################################################
while true; do
  ((++n))
  mkdir -p ${tmpdir}/${n}

  minc_anlm ${N4_VERBOSE:+--verbose} --rician --mt ${ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS} ${tmpdir}/$((n - 1))/corrected.mnc ${tmpdir}/${n}/t1.mnc

  #Combine the masks because sometimes beast misses badly biased cerebellum
  cp -f ${tmpdir}/$((n - 1))/classifymask.mnc ${tmpdir}/${n}/mask.mnc
  iMath 3 ${tmpdir}/${n}/mask_D.mnc MD ${tmpdir}/${n}/mask.mnc 1 1 box 1

  if [[ -n ${excludemask} ]]; then
    ImageMath 3 ${tmpdir}/${n}/mask_D.mnc m ${tmpdir}/${n}/mask_D.mnc ${excludemask}
  fi

  #Do an initial classification using the last round posteriors, remove outliers
  Atropos ${N4_VERBOSE:+--verbose} -d 3 -x ${tmpdir}/${n}/mask_D.mnc -c [5,0.001] -a ${tmpdir}/${n}/t1.mnc -s 1x2 -s 2x3 \
    -i PriorProbabilityImages[3,${tmpdir}/$((n - 1))/SegmentationPosteriors%d.mnc,${_arg_classification_prior_weight}] -k HistogramParzenWindows -m [0.1,1x1x1] \
    -o [${tmpdir}/${n}/classify.mnc,${tmpdir}/${n}/SegmentationPosteriors%d.mnc] -r 1 -p Aristotle[1] --winsorize-outliers BoxPlot \
    -l [0.69314718055994530942,1]

  classify_to_mask
  outlier_mask ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/class3.mnc ${tmpdir}/${n}/hotmask.mnc

  #Combine GM and WM probably images into a N4 mask,
  ImageMath 3 ${tmpdir}/${n}/weight.mnc PureTissueN4WeightMask ${tmpdir}/${n}/SegmentationPosteriors2.mnc ${tmpdir}/${n}/SegmentationPosteriors3.mnc
  ImageMath 3 ${tmpdir}/${n}/weight.mnc RescaleImage ${tmpdir}/${n}/weight.mnc 0 1

  ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/hotmask.mnc

  if [[ -n ${excludemask} ]]; then
    ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${excludemask}
  fi

  #Clip the classification weight and posteriors
  for item in ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/classify.mnc ${tmpdir}/${n}/SegmentationPosteriors1.mnc ${tmpdir}/${n}/SegmentationPosteriors2.mnc ${tmpdir}/${n}/SegmentationPosteriors3.mnc; do
    ImageMath 3 ${item} m ${item} ${tmpdir}/${n}/classifymask.mnc
    ImageMath 3 ${item} m ${item} ${tmpdir}/${n}/hotmask.mnc
  done

  #Always exclude 0 from correction
  minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -unsigned -byte -expression 'A[0]>0?1:0' ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/nonzero.mnc
  ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/nonzero.mnc

  do_N4_correct ${input} ${tmpdir}/initmask.mnc ${tmpdir}/${n}/classifymask.mnc ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/corrected.mnc ${tmpdir}/${n}/bias.mnc 4

  #Compute coeffcient of variation
  minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -zero -expression 'A[0]/A[1]' ${tmpdir}/$((n - 1))/bias.mnc ${tmpdir}/${n}/bias.mnc ${tmpdir}/${n}/ratio.mnc
  python -c "print(float(\"$(mincstats -quiet -stddev ${tmpdir}/${n}/ratio.mnc)\") / float(\"$(mincstats -quiet -mean ${tmpdir}/${n}/ratio.mnc)\"))" >>${tmpdir}/convergence.txt

  if [[ ${_arg_debug} == "off" ]]; then
    rm -rf ${tmpdir}/$((n - 1))
  fi

  # Break if greater than iterations or less than convergence threshold
  [[ (${n} -lt ${_arg_max_iterations}) && ($(python -c "print($(tail -1 ${tmpdir}/convergence.txt) > ${_arg_convergence_threshold})") == "True") ]] || break

done

echo "--------------------"
echo "Convergence results:"
cat ${tmpdir}/convergence.txt
echo "--------------------"

#If cropping is enabled, recrop the originput file and resample the mask again
if [[ ${_arg_autocrop} == "on" ]]; then
  ImageMath 3 ${originput} PadImage ${originput} 50
  antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -i ${tmpdir}/headmask.mnc -o ${tmpdir}/finalheadmask.mnc -r ${originput} -n GenericLabel
  ImageMath 3 ${originput} m ${originput} ${tmpdir}/finalheadmask.mnc
  ExtractRegionFromImageByMask 3 ${originput} ${tmpdir}/originput.crop.mnc ${tmpdir}/finalheadmask.mnc 1 10
  mv -f ${tmpdir}/originput.crop.mnc ${originput}
fi

#Transform all the working files into the original input space
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -i ${tmpdir}/${n}/classifymask.mnc -o ${tmpdir}/finalmask.mnc -r ${originput} -n GenericLabel
mincresample -clobber -quiet ${N4_VERBOSE:+-verbose} -keep -like ${originput} ${tmpdir}/${n}/weight.mnc ${tmpdir}/finalweight.mnc
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -i ${tmpdir}/bmask.mnc -o ${tmpdir}/finalbmask.mnc -r ${originput} -n GenericLabel
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -i ${tmpdir}/mnimask.mnc -o ${tmpdir}/finalmnimask.mnc -r ${originput} -n GenericLabel
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -i ${tmpdir}/${n}/classify.mnc -o ${tmpdir}/finalclassify.mnc -r ${originput} -n GenericLabel

#Create a FOV mask for the original input
minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -unsigned -byte -expression '1' ${originput} ${tmpdir}/originitmask.mnc

#Resample the average bias field into the original space
mv -f ${tmpdir}/${n}/avg_bias.mnc ${tmpdir}/${n}/avg_bias_orig.mnc
mincresample -clobber -quiet ${N4_VERBOSE:+-verbose} -like ${originput} -keep ${tmpdir}/${n}/avg_bias_orig.mnc ${tmpdir}/${n}/avg_bias.mnc
((++n))
mkdir -p ${tmpdir}/${n}

#Do the final correction
do_N4_correct ${originput} ${tmpdir}/originitmask.mnc ${tmpdir}/finalmask.mnc ${tmpdir}/finalweight.mnc ${tmpdir}/corrected.mnc ${tmpdir}/bias.mnc ${shrink_final_round}

#Denoise output if requested
if [[ ${_arg_denoise} == "on" ]]; then
  minc_anlm ${N4_VERBOSE:+--verbose} --rician --mt ${ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS} ${tmpdir}/corrected.mnc ${output}
else
  cp -f ${tmpdir}/corrected.mnc ${output}
fi

#Output final classification files if standalone
if [[ ${_arg_standalone} == "on" || ${_arg_debug} == "on" ]]; then
  cp -f ${tmpdir}/finalbmask.mnc $(dirname ${output})/$(basename ${output} .mnc).beastmask.mnc
  cp -f ${tmpdir}/finalmnimask.mnc $(dirname ${output})/$(basename ${output} .mnc).mnimask.mnc
  cp -f ${tmpdir}/finalclassify.mnc $(dirname $output)/$(basename ${output} .mnc).classify.mnc
  cp -f ${tmpdir}/finalmask.mnc $(dirname $output)/$(basename ${output} .mnc).mask.mnc
  minccalc -quiet ${N4_VERBOSE:+-verbose} -expression 'A[0]*A[1]' ${output} ${tmpdir}/finalmask.mnc ${tmpdir}/output.extracted.mnc
  ExtractRegionFromImageByMask 3 ${tmpdir}/output.extracted.mnc $(dirname $output)/$(basename ${output} .mnc).extracted.mnc ${tmpdir}/finalmask.mnc 1 10
fi

if [[ ${_arg_debug} == "off" ]]; then
  rm -rf ${tmpdir}
fi

# ] <-- needed because of Argbash
