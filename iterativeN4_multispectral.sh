#!/bin/bash

# Created by argbash-init v2.8.0
# Rearrange the order of options below according to what you would like to see in the help message.
# ARG_OPTIONAL_SINGLE([exclude],[e],[Mask file defining regions to exclude from classifcation, region is still corrected])
# ARG_OPTIONAL_SINGLE([config],[c],[Path to an alternative config file defining priors to use])
# ARG_OPTIONAL_SINGLE([logfile],[l],[Path to file to log all output])
# ARG_OPTIONAL_BOOLEAN([standalone],[s],[Script is run standalone so save all outputs])
# ARG_OPTIONAL_BOOLEAN([autocrop],[a],[Crop the final output to 10 mm around the skull])
# ARG_OPTIONAL_BOOLEAN([denoise],[d],[Denoise the final output files])
# ARG_OPTIONAL_SINGLE([max-iterations],[],[Maximum number of iterations to run],[10])
# ARG_OPTIONAL_SINGLE([convergence-threshold],[],[Coeffcient of variation limit between two bias field estimates],[0.01])
# ARG_OPTIONAL_SINGLE([classification-prior-weight],[],[How much weight is given to prior classification proabilities during iteration],[0.25])
# ARG_OPTIONAL_BOOLEAN([debug],[],[Debug mode, increase verbosity further, don't cleanup])
# ARG_VERBOSE([v])
# ARG_POSITIONAL_SINGLE([input],[T1w scan to be corrected])
# ARG_POSITIONAL_SINGLE([output],[Output filename for corrected T1w (also used as basename for other outputs)])
# ARGBASH_SET_INDENT([  ])
# ARGBASH_SET_DELIM([ =])
# ARG_OPTION_STACKING([getopt])
# ARG_RESTRICT_VALUES([no-local-options])
# ARG_DEFAULTS_POS([])
# ARG_HELP([iterativeN4_multispectral.sh is script which performs iterative inhomogeneity (bias field) correction and classification on T1w (and optionally T2w/PDw) MRI scans])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.8.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
  local _ret=$2
  test -n "$_ret" || _ret=1
  test "$_PRINT_HELP" = yes && print_help >&2
  echo "$1" >&2
  exit ${_ret}
}


evaluate_strictness()
{
  [[ "$2" =~ ^-(-(exclude|config|logfile|standalone|autocrop|denoise|max-iterations|convergence-threshold|classification-prior-weight|debug|verbose|input|output|help)$|[eclsadvh]) ]] && die "You have passed '$2' as a value of argument '$1', which makes it look like that you have omitted the actual value, since '$2' is an option accepted by this script. This is considered a fatal error."
}


begins_with_short_option()
{
  local first_option all_short_options='eclsadvh'
  first_option="${1:0:1}"
  test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_input=
_arg_output=
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_exclude=
_arg_config=
_arg_logfile=
_arg_standalone="off"
_arg_autocrop="off"
_arg_denoise="off"
_arg_max_iterations="10"
_arg_convergence_threshold="0.01"
_arg_classification_prior_weight="0.25"
_arg_debug="off"
_arg_verbose=0


print_help()
{
  printf '%s\n' "iterativeN4_multispectral.sh is script which performs iterative inhomogeneity (bias field) correction and classification on T1w (and optionally T2w/PDw) MRI scans"
  printf 'Usage: %s [-e|--exclude <arg>] [-c|--config <arg>] [-l|--logfile <arg>] [-s|--(no-)standalone] [-a|--(no-)autocrop] [-d|--(no-)denoise] [--max-iterations <arg>] [--convergence-threshold <arg>] [--classification-prior-weight <arg>] [--(no-)debug] [-v|--verbose] [-h|--help] <input> <output>\n' "$0"
  printf '\t%s\n' "<input>: T1w scan to be corrected"
  printf '\t%s\n' "<output>: Output filename for corrected T1w (also used as basename for other outputs)"
  printf '\t%s\n' "-e, --exclude: Mask file defining regions to exclude from classifcation, region is still corrected (no default)"
  printf '\t%s\n' "-c, --config: Path to an alternative config file defining priors to use (no default)"
  printf '\t%s\n' "-l, --logfile: Path to file to log all output (no default)"
  printf '\t%s\n' "-s, --standalone, --no-standalone: Script is run standalone so save all outputs (off by default)"
  printf '\t%s\n' "-a, --autocrop, --no-autocrop: Crop the final output to 10 mm around the skull (off by default)"
  printf '\t%s\n' "-d, --denoise, --no-denoise: Denoise the final output files (off by default)"
  printf '\t%s\n' "--max-iterations: Maximum number of iterations to run (default: '10')"
  printf '\t%s\n' "--convergence-threshold: Coeffcient of variation limit between two bias field estimates (default: '0.01')"
  printf '\t%s\n' "--classification-prior-weight: How much weight is given to prior classification proabilities during iteration (default: '0.25')"
  printf '\t%s\n' "--debug, --no-debug: Debug mode, increase verbosity further, don't cleanup (off by default)"
  printf '\t%s\n' "-v, --verbose: Set verbose output (can be specified multiple times to increase the effect)"
  printf '\t%s\n' "-h, --help: Prints help"
}


parse_commandline()
{
  _positionals_count=0
  while test $# -gt 0
  do
    _key="$1"
    case "$_key" in
      -e|--exclude)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_exclude="$2"
        shift
        evaluate_strictness "$_key" "$_arg_exclude"
        ;;
      --exclude=*)
        _arg_exclude="${_key##--exclude=}"
        evaluate_strictness "$_key" "$_arg_exclude"
        ;;
      -e*)
        _arg_exclude="${_key##-e}"
        evaluate_strictness "$_key" "$_arg_exclude"
        ;;
      -c|--config)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_config="$2"
        shift
        evaluate_strictness "$_key" "$_arg_config"
        ;;
      --config=*)
        _arg_config="${_key##--config=}"
        evaluate_strictness "$_key" "$_arg_config"
        ;;
      -c*)
        _arg_config="${_key##-c}"
        evaluate_strictness "$_key" "$_arg_config"
        ;;
      -l|--logfile)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_logfile="$2"
        shift
        evaluate_strictness "$_key" "$_arg_logfile"
        ;;
      --logfile=*)
        _arg_logfile="${_key##--logfile=}"
        evaluate_strictness "$_key" "$_arg_logfile"
        ;;
      -l*)
        _arg_logfile="${_key##-l}"
        evaluate_strictness "$_key" "$_arg_logfile"
        ;;
      -s|--no-standalone|--standalone)
        _arg_standalone="on"
        test "${1:0:5}" = "--no-" && _arg_standalone="off"
        ;;
      -s*)
        _arg_standalone="on"
        _next="${_key##-s}"
        if test -n "$_next" -a "$_next" != "$_key"
        then
          { begins_with_short_option "$_next" && shift && set -- "-s" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      -a|--no-autocrop|--autocrop)
        _arg_autocrop="on"
        test "${1:0:5}" = "--no-" && _arg_autocrop="off"
        ;;
      -a*)
        _arg_autocrop="on"
        _next="${_key##-a}"
        if test -n "$_next" -a "$_next" != "$_key"
        then
          { begins_with_short_option "$_next" && shift && set -- "-a" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      -d|--no-denoise|--denoise)
        _arg_denoise="on"
        test "${1:0:5}" = "--no-" && _arg_denoise="off"
        ;;
      -d*)
        _arg_denoise="on"
        _next="${_key##-d}"
        if test -n "$_next" -a "$_next" != "$_key"
        then
          { begins_with_short_option "$_next" && shift && set -- "-d" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      --max-iterations)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_max_iterations="$2"
        shift
        evaluate_strictness "$_key" "$_arg_max_iterations"
        ;;
      --max-iterations=*)
        _arg_max_iterations="${_key##--max-iterations=}"
        evaluate_strictness "$_key" "$_arg_max_iterations"
        ;;
      --convergence-threshold)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_convergence_threshold="$2"
        shift
        evaluate_strictness "$_key" "$_arg_convergence_threshold"
        ;;
      --convergence-threshold=*)
        _arg_convergence_threshold="${_key##--convergence-threshold=}"
        evaluate_strictness "$_key" "$_arg_convergence_threshold"
        ;;
      --classification-prior-weight)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_classification_prior_weight="$2"
        shift
        evaluate_strictness "$_key" "$_arg_classification_prior_weight"
        ;;
      --classification-prior-weight=*)
        _arg_classification_prior_weight="${_key##--classification-prior-weight=}"
        evaluate_strictness "$_key" "$_arg_classification_prior_weight"
        ;;
      --no-debug|--debug)
        _arg_debug="on"
        test "${1:0:5}" = "--no-" && _arg_debug="off"
        ;;
      -v|--verbose)
        _arg_verbose=$((_arg_verbose + 1))
        ;;
      -v*)
        _arg_verbose=$((_arg_verbose + 1))
        _next="${_key##-v}"
        if test -n "$_next" -a "$_next" != "$_key"
        then
          { begins_with_short_option "$_next" && shift && set -- "-v" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      -h|--help)
        print_help
        exit 0
        ;;
      -h*)
        print_help
        exit 0
        ;;
      *)
        _last_positional="$1"
        _positionals+=("$_last_positional")
        _positionals_count=$((_positionals_count + 1))
        ;;
    esac
    shift
  done
}


handle_passed_args_count()
{
  local _required_args_string="'input' and 'output'"
  test "${_positionals_count}" -ge 2 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 2 (namely: $_required_args_string), but got only ${_positionals_count}." 1
  test "${_positionals_count}" -le 2 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
  local _positional_name _shift_for=$1
  _positional_names="_arg_input _arg_output "

  shift "$_shift_for"
  for _positional_name in ${_positional_names}
  do
    test $# -gt 0 || break
    eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
    shift
  done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

set -euoE pipefail

#Special trick to redirect all output within script into logfile
if [[ -n ${_arg_logfile} ]]; then
  exec > >(tee -ia ${_arg_logfile})
  exec 2> >(tee -ia ${_arg_logfile} >&2)
fi

#If debug, print timestamps and every command run
if [[ ${_arg_debug} == "on" ]]; then
  set -xT
  set -o functrace
  PS4='+\t '
fi

#If verbose (or debug) turn on verbose outputs for commands
if [[ ${_arg_verbose} -ge 1 || ${_arg_debug} == "on" ]]; then
  N4_VERBOSE=1
fi

#Create temporary directory for work
tmpdir=$(mktemp -d)

#Setup exit trap for cleanup, don't do if debug
function finish() {
  if [[ ${_arg_debug} == "off" ]]; then
    rm -rf "${tmpdir}"
  fi

}
trap finish EXIT

failure() {
  local lineno=$1
  local msg=$2
  echo "Failed at $lineno: $msg"
}
trap 'failure ${LINENO} "$BASH_COMMAND"' ERR

#Set local parallelism inherited from QBATCH
export ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS=${THREADS_PER_COMMAND:-$(nproc)}
export OMP_NUM_THREADS=${ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS}

### DEFAULT PRIORS ###

#BeAST configuration
BEASTLIBRARY_DIR="${QUARANTINE_PATH}/resources/BEaST_libraries/combined"
BEAST_CONFIG=${BEASTLIBRARY_DIR}/default.1mm.conf

#mni_icbm152_nlin_sym_09c priors as default
REGISTRATIONMODEL="${QUARANTINE_PATH}/resources/mni_icbm152_nlin_sym_09c_minc2/mni_icbm152_t1_tal_nlin_sym_09c.mnc"
REGISTRATIONBRAINMASK="${QUARANTINE_PATH}/resources/mni_icbm152_nlin_sym_09c_minc2/mni_icbm152_t1_tal_nlin_sym_09c_mask.mnc"
WMPRIOR="${QUARANTINE_PATH}/resources/mni_icbm152_nlin_sym_09c_minc2/mni_icbm152_wm_tal_nlin_sym_09c.mnc"
GMPRIOR="${QUARANTINE_PATH}/resources/mni_icbm152_nlin_sym_09c_minc2/mni_icbm152_gm_tal_nlin_sym_09c.mnc"
CSFPRIOR="${QUARANTINE_PATH}/resources/mni_icbm152_nlin_sym_09c_minc2/mni_icbm152_csf_tal_nlin_sym_09c.mnc"

#Files used to define MNI space
RESAMPLEMODEL="${QUARANTINE_PATH}/resources/mni_icbm152_nlin_sym_09c_minc2/mni_icbm152_t1_tal_nlin_sym_09c.mnc"
RESAMPLEMODELBRAINMASK="${QUARANTINE_PATH}/resources/mni_icbm152_nlin_sym_09c_minc2/mni_icbm152_t1_tal_nlin_sym_09c_mask.mnc"

# Check config files, eventually argbash will do this
if [[ -n ${_arg_config} ]]; then
  if [[ -r ${_arg_config} ]]; then
    source ${_arg_config}
  else
    echo "iterativeN4_multispectral.sh ERROR: config file does not exist or is not readable" && exit 2
  fi
fi

if [[ ! -d ${BEASTLIBRARY_DIR} ]]; then
  echo "iterativeN4_multispectral.sh ERROR: ${BEASTLIBRARY_DIR} does not exist"
fi

for prior in ${REGISTRATIONMODEL} ${REGISTRATIONBRAINMASK} ${WMPRIOR} ${GMPRIOR} ${CSFPRIOR} ${RESAMPLEMODEL} ${RESAMPLEMODELBRAINMASK} ${BEAST_CONFIG}; do
  if [[ ! -s ${prior} ]]; then
    echo "iterativeN4_multispectral.sh ERROR: File ${prior} does not exist or is zero size" && exit 3
  fi
done

#Setup internal variables
output=${_arg_output}
originput=${_arg_input}

#Internal resampled input used for processing
input=${tmpdir}/t1.mnc

#Quick awk math function
calc() { awk "BEGIN { print "$*" }"; }

#Function for generating an outlier mask based on >3xIQR
#Mostly for excluding blood vessels when T1 was tuned improperly
function outlier_mask() {
  #Generate an outlier mask as median+3*IQR
  local outlier_input=$1
  local outlier_mask=$2
  local outlier_output=$3

  local median
  local pct25
  local pct75
  local threshold

  ImageMath 3 ${tmpdir}/${n}/outlier_mask.mnc GetLargestComponent ${outlier_mask}
  median=$(mincstats -quiet -median -hist_bins 4096 -mask ${tmpdir}/${n}/outlier_mask.mnc -mask_binvalue 1 ${outlier_input})
  pct25=$(mincstats -quiet -pctT 25 -hist_bins 4096 -mask ${tmpdir}/${n}/outlier_mask.mnc -mask_binvalue 1 ${outlier_input})
  pct75=$(mincstats -quiet -pctT 75 -hist_bins 4096 -mask ${tmpdir}/${n}/outlier_mask.mnc -mask_binvalue 1 ${outlier_input})
  threshold=$(calc "${median}+3*(${pct75}-${pct25})")

  minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -unsigned -byte -expression "A[0]>${threshold}?1:0" ${outlier_input} ${outlier_output}
  mincdefrag ${outlier_output} $(dirname ${outlier_output})/$(basename ${outlier_output} .mnc).defrag.mnc 1 6 1
  minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -unsigned -byte -expression "A[0]?0:1" $(dirname ${outlier_output})/$(basename ${outlier_output} .mnc).defrag.mnc ${outlier_output}
  rm -f $(dirname ${outlier_output})/$(basename ${outlier_output} .mnc).defrag.mnc ${tmpdir}/${n}/outlier_mask.mnc
}

#Function used to do bias field correction
function do_N4_correct() {
  #input fov mask weight output bias shrink
  local n4input=$1
  local n4initmask=$2
  local n4brainmask=$3
  local n4weight=$4
  local n4corrected=$5
  local n4bias=$6
  local n4shrink=$7
  local n4meanmask=$8
  local n4fwhm="${9:-0.05}"

  local min
  local max
  local pct25
  local pct75
  local npoints
  local histbins
  local n4brainmean
  local n4nonbrainmean

  #Calculate bins for N4 with Freedman-Diaconisâ€™s Rule
  min=$(mincstats -quiet -min -mask ${n4weight} -mask_range 1e-9,inf ${n4input})
  max=$(mincstats -quiet -max -mask ${n4weight} -mask_range 1e-9,inf ${n4input})
  npoints=$(mincstats -quiet -count -mask ${n4weight} -mask_range 1e-9,inf ${n4input})
  pct25=$(mincstats -quiet -pctT 25 -hist_bins 4096 -mask ${n4weight} -mask_range 1e-9,inf ${n4input})
  pct75=$(mincstats -quiet -pctT 75 -hist_bins 4096 -mask ${n4weight} -mask_range 1e-9,inf ${n4input})
  histbins=$(python -c "print( int((float(${max})-float(${min}))/(2.0 * (float(${pct75})-float(${pct25})) * float(${npoints})**(-1.0/3.0)) ))")

  N4BiasFieldCorrection ${N4_VERBOSE:+--verbose} -d 3 -s ${n4shrink} -w ${n4weight} -x ${n4initmask} \
    -b [ 200 ] -c [ 300x300x300x300,1e-5 ] --histogram-sharpening [ ${n4fwhm},0.01,${histbins} ] \
    -i ${n4input} \
    -o [ ${n4corrected},${n4bias} ] -r 0

  ImageMath 3 ${n4bias} / ${n4bias} $(mincstats -mean -mask ${n4brainmask} -mask_binvalue 1 -quiet ${n4bias})
  if ((n == 0)); then
    cp -f ${n4bias} ${tmpdir}/${n}/iterative_bias.mnc
    cp -f ${n4bias} ${tmpdir}/wholebrain_bias.mnc
    ImageMath 3 ${n4corrected} / ${input} ${tmpdir}/${n}/iterative_bias.mnc
    ImageMath 3 $(dirname ${n4corrected})/$(basename ${n4corrected} .mnc).norm.mnc RescaleImage ${n4corrected} 0 65535
  else
    iMath 3 $(dirname ${n4brainmask})/$(basename ${n4brainmask} .mnc)_D.mnc MD ${n4brainmask} 2 1 ball 1
    #Update ongoing bias field estimate
    ImageMath 3 ${tmpdir}/${n}/iterative_bias.mnc m ${tmpdir}/$((n - 1))/iterative_bias.mnc ${n4bias}
    #Rescale estimate to be mean 1 inside brain
    ImageMath 3 ${tmpdir}/${n}/iterative_bias.mnc / ${tmpdir}/${n}/iterative_bias.mnc $(mincstats -mean -mask ${n4brainmask} -mask_binvalue 1 -quiet ${tmpdir}/${n}/iterative_bias.mnc)
    #Combine wholebrain estiamtes from first round with within-brain estimate
    ImageMath 3 ${tmpdir}/${n}/iterative_bias_apply.mnc m ${tmpdir}/${n}/iterative_bias.mnc $(dirname ${n4brainmask})/$(basename ${n4brainmask} .mnc)_D.mnc
    minccalc -quiet ${N4_VERBOSE:+-verbose} -unsigned -double -expression "A[0]/$(mincstats -quiet -mean -mask $(dirname ${n4brainmask})/$(basename ${n4brainmask} .mnc)_D.mnc -mask_binvalue 0 ${tmpdir}/wholebrain_bias_crop.mnc)" ${tmpdir}/wholebrain_bias_crop.mnc ${tmpdir}/${n}/wholebrain_bias_apply.mnc
    ImageMath 3 ${tmpdir}/${n}/iterative_bias_apply.mnc addtozero ${tmpdir}/${n}/iterative_bias_apply.mnc ${tmpdir}/${n}/wholebrain_bias_apply.mnc
    ImageMath 3 ${tmpdir}/${n}/iterative_bias_apply.mnc addtozero ${tmpdir}/${n}/iterative_bias_apply.mnc 1
    #Correct original input brain
    ImageMath 3 ${n4corrected} / ${input} ${tmpdir}/${n}/iterative_bias_apply.mnc
    #Normalize and rescale intensity
    n4brainmean=$(mincstats -quiet -mean -mask ${n4meanmask} -mask_binvalue 1 ${n4corrected})
    n4nonbrainmean=$(mincstats -quiet -floor 10 -mean -mask $(dirname ${n4brainmask})/$(basename ${n4brainmask} .mnc)_D.mnc -mask_binvalue 0 ${n4corrected})
    minccalc -quiet ${N4_VERBOSE:+-verbose} -short -unsigned -expression "A[1]>0?clamp(32767*A[0]/${n4brainmean},0,65535):clamp(16384*A[0]/${n4nonbrainmean},0,65535)" \
      ${n4corrected} $(dirname ${n4brainmask})/$(basename ${n4brainmask} .mnc)_D.mnc $(dirname ${n4corrected})/$(basename ${n4corrected} .mnc).norm.mnc
  fi
  mv -f $(dirname ${n4corrected})/$(basename ${n4corrected} .mnc).norm.mnc ${n4corrected}
}

#Convert classify image into a mask
#Mostly a clone of the supersteps of the antsBrainExtraction supersteps
function classify_to_mask() {
  #Breakup classification and drop try to exclude small misclassified chunks
  ThresholdImage 3 ${tmpdir}/${n}/classify.mnc ${tmpdir}/${n}/class3.mnc 3 3 1 0
  ThresholdImage 3 ${tmpdir}/${n}/classify.mnc ${tmpdir}/${n}/class2.mnc 2 2 1 0
  ThresholdImage 3 ${tmpdir}/${n}/classify.mnc ${tmpdir}/${n}/class1.mnc 1 1 1 0
  #Get largest component
  ImageMath 3 ${tmpdir}/${n}/class3.mnc GetLargestComponent ${tmpdir}/${n}/class3.mnc
  ImageMath 3 ${tmpdir}/${n}/class2.mnc GetLargestComponent ${tmpdir}/${n}/class2.mnc

  #Fill holes in GM
  ImageMath 3 ${tmpdir}/${n}/class2.mnc FillHoles ${tmpdir}/${n}/class2.mnc 2

  #Erode CSF to just get any minimal ventical voxels
  iMath 3 ${tmpdir}/${n}/class1.mnc ME ${tmpdir}/${n}/class1.mnc 10 1 ball 1

  mincmath -quiet ${N4_VERBOSE:+-verbose} -unsigned -byte -labels -or ${tmpdir}/${n}/class2.mnc ${tmpdir}/${n}/class3.mnc ${tmpdir}/${n}/class1.mnc \
    ${tmpdir}/${n}/classifymask.mnc

  iMath 3 ${tmpdir}/${n}/classifymask.mnc ME ${tmpdir}/${n}/classifymask.mnc 2 1 ball 1
  ImageMath 3 ${tmpdir}/${n}/classifymask.mnc GetLargestComponent ${tmpdir}/${n}/classifymask.mnc
  iMath 3 ${tmpdir}/${n}/classifymask.mnc MD ${tmpdir}/${n}/classifymask.mnc 4 1 ball 1
  ImageMath 3 ${tmpdir}/${n}/classifymask.mnc FillHoles ${tmpdir}/${n}/classifymask.mnc 2
  iMath 3 ${tmpdir}/${n}/bmask_E.mnc ME ${tmpdir}/bmask.mnc 4 1 ball 1
  ImageMath 3 ${tmpdir}/${n}/classifymask.mnc addtozero ${tmpdir}/${n}/classifymask.mnc ${tmpdir}/${n}/bmask_E.mnc
  iMath 3 ${tmpdir}/${n}/classifymask.mnc MD ${tmpdir}/${n}/classifymask.mnc 5 1 ball 1
  iMath 3 ${tmpdir}/${n}/classifymask.mnc ME ${tmpdir}/${n}/classifymask.mnc 5 1 ball 1

  ThresholdImage 3 ${tmpdir}/${n}/classify.mnc ${tmpdir}/${n}/class3.mnc 3 3 1 0
}

##########START OF SCRIPT#############
#Forceably convert to MINC2, and clamp range to avoid negative numbers
mincconvert -2 ${originput} ${tmpdir}/originput.mnc
mincmath -quiet ${N4_VERBOSE:+-verbose} -clamp -const2 0 $(mincstats -quiet -max ${tmpdir}/originput.mnc) ${tmpdir}/originput.mnc ${tmpdir}/originput.clamp.mnc
mv -f ${tmpdir}/originput.clamp.mnc ${tmpdir}/originput.mnc
originput=${tmpdir}/originput.mnc

#Isotropize, and normalize intensity range
isostep=1
ResampleImage 3 ${originput} ${input} ${isostep}x${isostep}x${isostep} 0 4
mincmath -quiet ${N4_VERBOSE:+-verbose} -clamp -const2 0 $(mincstats -max -quiet ${input}) ${input} ${tmpdir}/input.clamp.mnc
ImageMath 3 ${input} RescaleImage ${tmpdir}/input.clamp.mnc 0 65535
rm -f ${tmpdir}/input.clamp.mnc

#If lesion mask exists, negate it to produce a multiplicative exlcusion mask, resample to internal resolution
if [[ -n ${_arg_exclude} ]]; then
  ImageMath 3 ${tmpdir}/exclude.mnc Neg ${_arg_exclude}
  excludemask=${tmpdir}/exclude.mnc
  antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -i ${excludemask} -r ${input} -n GenericLabel -o ${excludemask}
else
  excludemask=""
fi

################################################################################
#Round 0, do a precorrection, then form mask from 75% of Otsu threshold
#Also estimate headmask and crop the internal files
################################################################################
n=0

mkdir -p ${tmpdir}/${n}

minc_anlm ${N4_VERBOSE:+--verbose} --mt ${ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS} ${input} ${tmpdir}/${n}/t1.mnc

#Initial threshold of greater than 0.5 of mean intensity
ImageMath 3 ${tmpdir}/${n}/weight.mnc ThresholdAtMean ${tmpdir}/${n}/t1.mnc 0.5
ImageMath 3 ${tmpdir}/${n}/weight.mnc GetLargestComponent ${tmpdir}/${n}/weight.mnc

#Generate a whole-image mask to force N4 to always do correction over whole image
minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -unsigned -byte -expression '1' ${tmpdir}/${n}/t1.mnc ${tmpdir}/initmask.mnc
minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -unsigned -byte -expression 'A[0]>1.01?1:0' ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/nonzero.mnc
ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/nonzero.mnc
iMath 3 ${tmpdir}/${n}/weight.mnc ME ${tmpdir}/${n}/weight.mnc 1 1 box 1
mincdefrag ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/weight.defrag.mnc 1 27
iMath 3 ${tmpdir}/${n}/weight.mnc MD ${tmpdir}/${n}/weight.defrag.mnc 1 1 box 1
ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/nonzero.mnc
do_N4_correct ${tmpdir}/${n}/t1.mnc ${tmpdir}/initmask.mnc ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/precorrected.mnc ${tmpdir}/${n}/bias.mnc 4 ${tmpdir}/${n}/weight.mnc 0.15
minc_anlm --clobber ${N4_VERBOSE:+--verbose} --mt ${ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS} ${tmpdir}/${n}/precorrected.mnc ${tmpdir}/${n}/t1.mnc

#First try registration to MNI space to get headmask
antsRegistration ${N4_VERBOSE:+--verbose} -d 3 --float 1 --minc \
  --output [ ${tmpdir}/${n}/mni ] \
  --use-histogram-matching 1 \
  --initial-moving-transform [ ${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1 ] \
  --transform Translation[ 0.5 ] \
  --metric Mattes[ ${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1,32,Regular,0.25 ] \
  --convergence [ 2025x2025x2025,1e-6,10 ] \
  --shrink-factors 8x8x4 \
  --smoothing-sigmas 13.5891488046x6.7945744023x3.39728720115mm \
  --transform Rigid[ 0.5 ] \
  --metric Mattes[ ${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1,64,Regular,0.25 ] \
  --convergence [ 2025x2025x2025,1e-6,10 ] \
  --shrink-factors 8x4x2 \
  --smoothing-sigmas 6.7945744023x3.39728720115x1.69864360058mm \
  --transform Similarity[ 0.25 ] \
  --metric Mattes[ ${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1,128,Regular,0.5 ] \
  --convergence [ 2025x2025x750,1e-6,10 ] \
  --shrink-factors 4x2x1 \
  --smoothing-sigmas 3.39728720115x1.69864360058x0.849321800288mm \
  --transform Affine[ 0.125 ] \
  --metric Mattes[ ${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1,256,Regular,0.5 ] \
  --convergence [ 2025x2025,1e-6,10 ] \
  --shrink-factors 4x2 \
  --smoothing-sigmas 3.39728720115x1.69864360058mm

#Generate model headmask
ImageMath 3 ${tmpdir}/modelheadmask.mnc ThresholdAtMean ${REGISTRATIONMODEL} 0.5
ImageMath 3 ${tmpdir}/modelheadmask.mnc FillHoles ${tmpdir}/modelheadmask.mnc 2

#Initial threshold of greater than 0.5*otsu threshold
minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -unsigned -byte -expression "A[0]>0.5*$(mincstats -quiet -floor 1e-6 -bins 4096 -biModalT ${tmpdir}/${n}/t1.mnc)?1:0" ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/weight.mnc
ImageMath 3 ${tmpdir}/${n}/weight.mnc GetLargestComponent ${tmpdir}/${n}/weight.mnc

#Use exclude mask if provided
if [[ -n ${excludemask} ]]; then
  ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${excludemask}
fi

#Generate a whole-image mask to force N4 to always do correction over whole image
minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -unsigned -byte -expression '1' ${input} ${tmpdir}/initmask.mnc

#Always exclude 0 from correction
minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -unsigned -byte -expression "A[0]>1.01?1:0" ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/nonzero.mnc
ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/nonzero.mnc
iMath 3 ${tmpdir}/${n}/weight.mnc ME ${tmpdir}/${n}/weight.mnc 1 1 box 1
mincdefrag ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/weight.defrag.mnc 1 27
iMath 3 ${tmpdir}/${n}/weight.mnc MD ${tmpdir}/${n}/weight.defrag.mnc 1 1 box 1
ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/nonzero.mnc

do_N4_correct ${input} ${tmpdir}/initmask.mnc ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/corrected.mnc ${tmpdir}/${n}/bias.mnc 2 ${tmpdir}/${n}/weight.mnc 0.1

#Resample headmask into subject space, zero background and recrop
ImageMath 3 ${input} PadImage ${input} 50
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -i ${tmpdir}/modelheadmask.mnc -t [ ${tmpdir}/${n}/mni0_GenericAffine.xfm,1 ] -o ${tmpdir}/headmask.mnc -r ${input} -n GenericLabel
ImageMath 3 ${input} m ${input} ${tmpdir}/headmask.mnc
ExtractRegionFromImageByMask 3 ${input} ${tmpdir}/input.crop.mnc ${tmpdir}/headmask.mnc 1 10
mv -f ${tmpdir}/input.crop.mnc ${input}
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -i ${tmpdir}/modelheadmask.mnc -t [ ${tmpdir}/${n}/mni0_GenericAffine.xfm,1 ] -o ${tmpdir}/headmask.mnc -r ${input} -n GenericLabel

antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -i ${tmpdir}/${n}/corrected.mnc -o ${tmpdir}/${n}/corrected.mnc -r ${input}
ImageMath 3 ${tmpdir}/${n}/corrected.mnc m ${tmpdir}/${n}/corrected.mnc ${tmpdir}/headmask.mnc

mincresample -quiet ${N4_VERBOSE:+-verbose} -clobber -like ${input} ${tmpdir}/wholebrain_bias.mnc ${tmpdir}/wholebrain_bias_crop.mnc
mincresample -quiet ${N4_VERBOSE:+-verbose} -clobber -like ${input} ${tmpdir}/${n}/iterative_bias.mnc ${tmpdir}/${n}/iterative_bias_crop.mnc
minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -unsigned -byte -expression '1' ${input} ${tmpdir}/initmask.mnc
mv -f ${tmpdir}/${n}/iterative_bias_crop.mnc ${tmpdir}/${n}/iterative_bias.mnc

################################################################################
#Round 1, N4 over kmeans estimates WM/GM mask using model affine brainmask
################################################################################
((++n))
mkdir -p ${tmpdir}/${n}

minc_anlm ${N4_VERBOSE:+--verbose} --mt ${ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS} ${tmpdir}/$((n - 1))/corrected.mnc ${tmpdir}/${n}/t1.mnc

#First try registration to MNI space, multistep
antsRegistration ${N4_VERBOSE:+--verbose} -d 3 --float 1 --minc \
  --output [ ${tmpdir}/${n}/mni ] \
  --use-histogram-matching 1 \
  --initial-moving-transform ${tmpdir}/$((n - 1))/mni0_GenericAffine.xfm \
  --transform Translation[ 0.5 ] \
  --metric Mattes[ ${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1,32,Regular,0.25 ] \
  --convergence [ 2025x2025x2025,1e-6,10 ] \
  --shrink-factors 8x8x8 \
  --smoothing-sigmas 13.5891488046x11.890505204x10.1918616035mm \
  --masks [ NOMASK,NOMASK ] \
  --transform Rigid[ 0.5 ] \
  --metric Mattes[ ${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1,32,Regular,0.25 ] \
  --convergence [ 2025x2025x2025,1e-6,10 ] \
  --shrink-factors 8x8x8 \
  --smoothing-sigmas 11.890505204x10.1918616035x8.49321800288mm \
  --masks [ NOMASK,NOMASK ] \
  --transform Similarity[ 0.25 ] \
  --metric Mattes[ ${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1,43,Regular,0.5 ] \
  --convergence [ 2025x2025x2025,1e-6,10 ] \
  --shrink-factors 8x8x8 \
  --smoothing-sigmas 10.1918616035x8.49321800288x6.7945744023mm \
  --masks [ NOMASK,NOMASK ] \
  --transform Affine[ 0.125 ] \
  --metric Mattes[ ${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1,64,Regular,0.75 ] \
  --convergence [ 2025x2025x2025,1e-6,10 ] \
  --shrink-factors 8x8x6 \
  --smoothing-sigmas 8.49321800288x6.7945744023x5.09593080173mm \
  --masks [ NOMASK,NOMASK ] \
  --transform Affine[ 0.0625 ] \
  --metric Mattes[ ${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1,256,None ] \
  --convergence [ 2025x2025x250,1e-6,20 ] \
  --shrink-factors 4x2x1 \
  --smoothing-sigmas 3.39728720115x1.69864360058x0mm \
  --masks [ ${REGISTRATIONBRAINMASK},${tmpdir}/headmask.mnc ]

antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -r ${tmpdir}/${n}/t1.mnc -t [ ${tmpdir}/${n}/mni0_GenericAffine.xfm,1 ] -i ${GMPRIOR} -o ${tmpdir}/${n}/gmprob.mnc -n Linear
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -r ${tmpdir}/${n}/t1.mnc -t [ ${tmpdir}/${n}/mni0_GenericAffine.xfm,1 ] -i ${WMPRIOR} -o ${tmpdir}/${n}/wmprob.mnc -n Linear
minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -unsigned -byte -expression '(A[0]>0.5||A[1]>0.5)?1:0' ${tmpdir}/${n}/gmprob.mnc ${tmpdir}/${n}/wmprob.mnc ${tmpdir}/${n}/mnimask.mnc

iMath 3 ${tmpdir}/${n}/mnimask.mnc MD ${tmpdir}/${n}/mnimask.mnc 3 1 ball 1
ImageMath 3 ${tmpdir}/${n}/mnimask.mnc FillHoles ${tmpdir}/${n}/mnimask.mnc 2
iMath 3 ${tmpdir}/${n}/mnimask.mnc ME ${tmpdir}/${n}/mnimask.mnc 1 1 ball 1

#Generate a hotmask using the existing weight mask
outlier_mask ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/mnimask.mnc ${tmpdir}/${n}/hotmask.mnc
iMath 3 ${tmpdir}/${n}/mnimask_D.mnc MD ${tmpdir}/${n}/mnimask.mnc 1 1 ball 1
ImageMath 3 ${tmpdir}/${n}/kmeansmask.mnc m ${tmpdir}/${n}/mnimask_D.mnc ${tmpdir}/${n}/hotmask.mnc

#Do a quick kmeans to get gm/wm and make a hard mask for weight
ThresholdImage 3 ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/weight.mnc Kmeans 2 ${tmpdir}/${n}/kmeansmask.mnc
ThresholdImage 3 ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/weight.mnc 2 3 1 0
iMath 3 ${tmpdir}/${n}/weight.mnc ME ${tmpdir}/${n}/weight.mnc 1 1 ball 1
ImageMath 3 ${tmpdir}/${n}/weight.mnc GetLargestComponent ${tmpdir}/${n}/weight.mnc
iMath 3 ${tmpdir}/${n}/weight.mnc MD ${tmpdir}/${n}/weight.mnc 1 1 ball 1

#User provided exclusion mask
if [[ -n ${excludemask} ]]; then
  ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${excludemask}
fi

#Remove outliers round 2
outlier_mask ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/hotmask.mnc
ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/hotmask.mnc
ImageMath 3 ${tmpdir}/${n}/weight.mnc GetLargestComponent ${tmpdir}/${n}/weight.mnc

#Always exclude 0 from correction
minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -unsigned -byte -expression 'A[0]>1.01?1:0' ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/nonzero.mnc
ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/nonzero.mnc

do_N4_correct ${tmpdir}/${n}/t1.mnc ${tmpdir}/initmask.mnc ${tmpdir}/${n}/kmeansmask.mnc ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/corrected.mnc ${tmpdir}/${n}/bias.mnc 4 ${tmpdir}/${n}/weight.mnc

#Calculate coeffcient of variation between this round bias field and prior round
minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -zero -expression 'A[0]/A[1]' ${tmpdir}/$((n - 1))/iterative_bias.mnc ${tmpdir}/${n}/iterative_bias.mnc ${tmpdir}/${n}/ratio.mnc
python -c "print(float(\"$(mincstats -quiet -mask ${tmpdir}/${n}/kmeansmask.mnc -mask_binvalue 1 -stddev ${tmpdir}/${n}/ratio.mnc)\") / float(\"$(mincstats -quiet -mask ${tmpdir}/${n}/kmeansmask.mnc -mask_binvalue 1 -mean ${tmpdir}/${n}/ratio.mnc)\"))" >>${tmpdir}/convergence.txt

if [[ ${_arg_debug} == "off" ]]; then
  rm -rf ${tmpdir}/$((n - 1))
fi

################################################################################
#Round 2, N4 with kmeans GM/WM mask within combination of model affine and beastmask
################################################################################
((++n))
mkdir -p ${tmpdir}/${n}

minc_anlm ${N4_VERBOSE:+--verbose} --mt ${ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS} ${tmpdir}/$((n - 1))/corrected.mnc ${tmpdir}/${n}/t1.mnc

#Register to MNI space
antsRegistration ${N4_VERBOSE:+--verbose} -d 3 --float 1 --minc \
  --output [ ${tmpdir}/${n}/mni ] \
  --use-histogram-matching 1 \
  --initial-moving-transform ${tmpdir}/$((n - 1))/mni0_GenericAffine.xfm \
  --transform Similarity[ 0.25 ] \
  --metric Mattes[ ${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1,43,Regular,0.5 ] \
  --convergence [ 2025x2025x2025,1e-6,10 ] \
  --shrink-factors 8x8x8 \
  --smoothing-sigmas 10.1918616035x8.49321800288x6.7945744023mm \
  --masks [ NOMASK,NOMASK ] \
  --transform Affine[ 0.125 ] \
  --metric Mattes[ ${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1,64,Regular,0.75 ] \
  --convergence [ 2025x2025x2025,1e-6,10 ] \
  --shrink-factors 8x8x6 \
  --smoothing-sigmas 8.49321800288x6.7945744023x5.09593080173mm \
  --masks [ NOMASK,NOMASK ] \
  --transform Affine[ 0.0625 ] \
  --metric Mattes[ ${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1,256,None ] \
  --convergence [ 2025x2025x250,1e-6,20 ] \
  --shrink-factors 4x2x1 \
  --smoothing-sigmas 3.39728720115x1.69864360058x0mm \
  --masks [ ${REGISTRATIONBRAINMASK},${tmpdir}/$((n - 1))/mnimask.mnc ]

#Make MNI-space copy of brain for BeAST
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -i ${tmpdir}/${n}/t1.mnc -t ${tmpdir}/${n}/mni0_GenericAffine.xfm -n BSpline[ 5 ] -o ${tmpdir}/${n}/mni.mnc -r ${RESAMPLEMODEL}
#BSpline[ 5 ] does weird things to intensity, clip back to positive range
mincmath -quiet ${N4_VERBOSE:+-verbose} -clamp -const2 0 $(mincstats -quiet -max ${tmpdir}/${n}/mni.mnc) ${tmpdir}/${n}/mni.mnc ${tmpdir}/${n}/mni.clamp.mnc
mv -f ${tmpdir}/${n}/mni.clamp.mnc ${tmpdir}/${n}/mni.mnc

#Shrink the MNI mask for the first intensity matching
iMath 3 ${tmpdir}/${n}/shrinkmask.mnc ME ${RESAMPLEMODELBRAINMASK} 3 1 ball 1

#Intensity normalize
volume_pol --order 1 --min 0 --max 100 --noclamp ${tmpdir}/${n}/mni.mnc ${RESAMPLEMODEL} --source_mask ${tmpdir}/${n}/shrinkmask.mnc --target_mask ${RESAMPLEMODELBRAINMASK} ${tmpdir}/${n}/mni.norm.mnc

#Run a quick beast to get a brain mask
mincbeast ${N4_VERBOSE:+-verbose} -v2 -double -fill -median -same_res -flip -conf ${BEAST_CONFIG} ${BEASTLIBRARY_DIR} ${tmpdir}/${n}/mni.norm.mnc ${tmpdir}/${n}/beastmask.mnc

#Resample beast mask and MNI mask to native space
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -r ${tmpdir}/${n}/t1.mnc -t [ ${tmpdir}/${n}/mni0_GenericAffine.xfm,1 ] -i ${GMPRIOR} -o ${tmpdir}/${n}/gmprob.mnc -n Linear
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -r ${tmpdir}/${n}/t1.mnc -t [ ${tmpdir}/${n}/mni0_GenericAffine.xfm,1 ] -i ${WMPRIOR} -o ${tmpdir}/${n}/wmprob.mnc -n Linear
minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -unsigned -byte -expression '(A[0]>0.5||A[1]>0.5)?1:0' ${tmpdir}/${n}/gmprob.mnc ${tmpdir}/${n}/wmprob.mnc ${tmpdir}/${n}/mnimask.mnc
iMath 3 ${tmpdir}/${n}/mnimask.mnc MD ${tmpdir}/${n}/mnimask.mnc 3 1 ball 1
ImageMath 3 ${tmpdir}/${n}/mnimask.mnc FillHoles ${tmpdir}/${n}/mnimask.mnc 2
iMath 3 ${tmpdir}/${n}/mnimask.mnc ME ${tmpdir}/${n}/mnimask.mnc 1 1 ball 1


antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -r ${tmpdir}/${n}/t1.mnc -t [ ${tmpdir}/${n}/mni0_GenericAffine.xfm,1 ] -i ${tmpdir}/${n}/beastmask.mnc -o ${tmpdir}/${n}/bmask.mnc -n GenericLabel

#BeAST Failure mode of a chunk of almost unattached voxels
iMath 3 ${tmpdir}/${n}/bmask.mnc ME ${tmpdir}/${n}/bmask.mnc 1 1 ball 1
ImageMath 3 ${tmpdir}/${n}/bmask.mnc GetLargestComponent ${tmpdir}/${n}/bmask.mnc
iMath 3 ${tmpdir}/${n}/bmask.mnc MD ${tmpdir}/${n}/bmask.mnc 1 1 ball 1

#Beastmask is mask for this round
cp -f ${tmpdir}/${n}/bmask.mnc ${tmpdir}/${n}/mask.mnc

#Generate a hotmask using the existing weight mask
outlier_mask ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/mask.mnc ${tmpdir}/${n}/hotmask.mnc
iMath 3 ${tmpdir}/${n}/mask_D.mnc MD ${tmpdir}/${n}/mask.mnc 1 1 ball 1
ImageMath 3 ${tmpdir}/${n}/kmeansmask.mnc m ${tmpdir}/${n}/mask_D.mnc ${tmpdir}/${n}/hotmask.mnc

#Do a quick kmeans to get gm/wm and make a hard mask for weight
ThresholdImage 3 ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/weight.mnc Kmeans 2 ${tmpdir}/${n}/kmeansmask.mnc
ThresholdImage 3 ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/weight.mnc 2 3 1 0
iMath 3 ${tmpdir}/${n}/weight.mnc ME ${tmpdir}/${n}/weight.mnc 1 1 ball 1
ImageMath 3 ${tmpdir}/${n}/weight.mnc GetLargestComponent ${tmpdir}/${n}/weight.mnc
iMath 3 ${tmpdir}/${n}/weight.mnc MD ${tmpdir}/${n}/weight.mnc 1 1 ball 1

if [[ -n ${excludemask} ]]; then
  ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${excludemask}
fi

#Generate a hotmask using the kmeans brainmask
outlier_mask ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/hotmask.mnc
#Remove really hot voxels from weight for N4
ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/hotmask.mnc
ImageMath 3 ${tmpdir}/${n}/weight.mnc GetLargestComponent ${tmpdir}/${n}/weight.mnc

#Always exclude 0 from correction
minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -unsigned -byte -expression 'A[0]>1.01?1:0' ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/nonzero.mnc
ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/nonzero.mnc

do_N4_correct ${tmpdir}/${n}/t1.mnc ${tmpdir}/initmask.mnc ${tmpdir}/${n}/kmeansmask.mnc ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/corrected.mnc ${tmpdir}/${n}/bias.mnc 4 ${tmpdir}/${n}/weight.mnc

minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -zero -expression 'A[0]/A[1]' ${tmpdir}/$((n - 1))/iterative_bias.mnc ${tmpdir}/${n}/iterative_bias.mnc ${tmpdir}/${n}/ratio.mnc
python -c "print(float(\"$(mincstats -quiet -mask ${tmpdir}/${n}/kmeansmask.mnc -mask_binvalue 1 -stddev ${tmpdir}/${n}/ratio.mnc)\") / float(\"$(mincstats -quiet -mask ${tmpdir}/${n}/kmeansmask.mnc -mask_binvalue 1 -mean ${tmpdir}/${n}/ratio.mnc)\"))" >>${tmpdir}/convergence.txt

if [[ ${_arg_debug} == "off" ]]; then
  rm -rf ${tmpdir}/$((n - 1))
fi

################################################################################
#Round 3, N4 with classification poserior probabilties, boostrapped from model priors
################################################################################
((++n))
mkdir -p ${tmpdir}/${n}

minc_anlm ${N4_VERBOSE:+--verbose} --mt ${ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS} ${tmpdir}/$((n - 1))/corrected.mnc ${tmpdir}/${n}/t1.mnc

#Affine register to MNI space, tweak registration
antsRegistration ${N4_VERBOSE:+--verbose} -d 3 --float 1 --minc \
  --output [ ${tmpdir}/${n}/mni ] \
  --use-histogram-matching 1 \
  --initial-moving-transform ${tmpdir}/$((n - 1))/mni0_GenericAffine.xfm \
  --transform Affine[ 0.0625 ] \
  --metric Mattes[ ${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1,256,None ] \
  --convergence [ 2025x2025x250,1e-6,20 ] \
  --shrink-factors 4x2x1 \
  --smoothing-sigmas 3.39728720115x1.69864360058x0mm \
  --masks [ ${REGISTRATIONBRAINMASK},${tmpdir}/$((n - 1))/mask.mnc ]

antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -i ${tmpdir}/${n}/t1.mnc -t ${tmpdir}/${n}/mni0_GenericAffine.xfm -n BSpline[ 5 ] -o ${tmpdir}/${n}/mni.mnc -r ${RESAMPLEMODEL}
mincmath -quiet ${N4_VERBOSE:+-verbose} -clamp -const2 0 $(mincstats -quiet -max ${tmpdir}/${n}/mni.mnc) ${tmpdir}/${n}/mni.mnc ${tmpdir}/${n}/mni.clamp.mnc
mv -f ${tmpdir}/${n}/mni.clamp.mnc ${tmpdir}/${n}/mni.mnc

#Shrink last round's beastmask for normalization
iMath 3 ${tmpdir}/${n}/shrinkmask.mnc ME ${tmpdir}/$((n - 1))/beastmask.mnc 3 1 ball 1

#Intensity normalize
volume_pol --order 1 --min 0 --max 100 --noclamp ${tmpdir}/${n}/mni.mnc ${RESAMPLEMODEL} --source_mask ${tmpdir}/${n}/shrinkmask.mnc --target_mask ${RESAMPLEMODELBRAINMASK} ${tmpdir}/${n}/mni.norm.mnc

#Run a quick beast to get a brain mask
mincbeast ${N4_VERBOSE:+-verbose} -v2 -double -fill -median -same_res -flip -conf ${BEAST_CONFIG} ${BEASTLIBRARY_DIR} ${tmpdir}/${n}/mni.norm.mnc ${tmpdir}/${n}/beastmask.mnc

antsApplyTransforms -i ${tmpdir}/${n}/beastmask.mnc -t [ ${tmpdir}/${n}/mni0_GenericAffine.xfm,1 ] -r ${tmpdir}/${n}/t1.mnc -o ${tmpdir}/${n}/bmask.mnc ${N4_VERBOSE:+--verbose} -d 3 -n GenericLabel

antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -r ${tmpdir}/${n}/t1.mnc -t [ ${tmpdir}/${n}/mni0_GenericAffine.xfm,1 ] -i ${GMPRIOR} -o ${tmpdir}/${n}/gmprob.mnc -n Linear
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -r ${tmpdir}/${n}/t1.mnc -t [ ${tmpdir}/${n}/mni0_GenericAffine.xfm,1 ] -i ${WMPRIOR} -o ${tmpdir}/${n}/wmprob.mnc -n Linear
minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -unsigned -byte -expression '(A[0]>0.5||A[1]>0.5)?1:0' ${tmpdir}/${n}/gmprob.mnc ${tmpdir}/${n}/wmprob.mnc ${tmpdir}/${n}/mniaffinemask.mnc
iMath 3 ${tmpdir}/${n}/mniaffinemask.mnc MD ${tmpdir}/${n}/mniaffinemask.mnc 3 1 ball 1
ImageMath 3 ${tmpdir}/${n}/mniaffinemask.mnc FillHoles ${tmpdir}/${n}/mniaffinemask.mnc 2
iMath 3 ${tmpdir}/${n}/mniaffinemask.mnc ME ${tmpdir}/${n}/mniaffinemask.mnc 1 1 ball 1

#BeAST Failure mode of a chunk of almost unattached voxels
iMath 3 ${tmpdir}/${n}/bmask.mnc ME ${tmpdir}/${n}/bmask.mnc 1 1 ball 1
ImageMath 3 ${tmpdir}/${n}/bmask.mnc GetLargestComponent ${tmpdir}/${n}/bmask.mnc
iMath 3 ${tmpdir}/${n}/bmask.mnc MD ${tmpdir}/${n}/bmask.mnc 1 1 ball 1

#Last time beast is run, copy outside loops
cp -f ${tmpdir}/${n}/bmask.mnc ${tmpdir}/bmask.mnc

#Create extracted model for nonlinear registration
cp -f ${tmpdir}/${n}/bmask.mnc ${tmpdir}/${n}/extractmask.mnc
iMath 3 ${tmpdir}/${n}/extractmask.mnc MD ${tmpdir}/${n}/extractmask.mnc 2 1 ball 1
iMath 3 ${tmpdir}/${n}/modelextractmask.mnc MD ${REGISTRATIONBRAINMASK} 2 1 ball 1

#Extract t1
minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -expression 'A[0]*A[1]' ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/extractmask.mnc ${tmpdir}/${n}/t1.extracted.mnc

ImageMath 3 ${tmpdir}/${n}/modelextracted.mnc PadImage ${REGISTRATIONMODEL} 50
antsApplyTransforms -i ${tmpdir}/${n}/modelextractmask.mnc -r ${tmpdir}/${n}/modelextracted.mnc -o ${tmpdir}/${n}/modelextractmask.mnc -n GenericLabel ${N4_VERBOSE:+--verbose} -d 3
ImageMath 3 ${tmpdir}/${n}/modelextracted.mnc m ${tmpdir}/${n}/modelextracted.mnc ${tmpdir}/${n}/modelextractmask.mnc
ExtractRegionFromImageByMask 3 ${tmpdir}/${n}/modelextracted.mnc ${tmpdir}/${n}/modelextracted2.mnc ${tmpdir}/${n}/modelextractmask.mnc 1 10
mv -f ${tmpdir}/${n}/modelextracted2.mnc ${tmpdir}/${n}/modelextracted.mnc

#Non linearly register priors
antsRegistration ${N4_VERBOSE:+--verbose} -d 3 --float 1 --minc \
  --output [ ${tmpdir}/${n}/nonlin ] \
  --initial-moving-transform ${tmpdir}/${n}/mni0_GenericAffine.xfm \
  --use-histogram-matching 1 \
  --transform SyN[ 0.1,3,0 ] \
  --metric CC[ ${tmpdir}/${n}/modelextracted.mnc,${tmpdir}/${n}/t1.extracted.mnc,1,2,None ] \
  --convergence [ 2025x2025x2025x2025x2025x2025x2025x2025x2025x2025x2025x2025x2025x675x225x75x25,1e-5,10 ] \
  --shrink-factors 8x8x8x8x8x8x8x8x8x7x6x5x4x3x2x2x2 \
  --smoothing-sigmas 13.5891488046x12.7398270043x11.890505204x11.0411834037x10.1918616035x9.34253980317x8.49321800288x7.64389620259x6.7945744023x5.94525260202x5.09593080173x4.24660900144x3.39728720115x2.54796540086x1.69864360058x0.849321800288x0mm

#Resample MNI Priors to Native space for classification
antsApplyTransforms -i ${WMPRIOR} -t [ ${tmpdir}/${n}/mni0_GenericAffine.xfm,1 ] -t ${tmpdir}/${n}/nonlin1_inverse_NL.xfm -r ${tmpdir}/${n}/t1.mnc -o ${tmpdir}/${n}/SegmentationPrior3.mnc ${N4_VERBOSE:+--verbose} -d 3 -n Linear
antsApplyTransforms -i ${GMPRIOR} -t [ ${tmpdir}/${n}/mni0_GenericAffine.xfm,1 ] -t ${tmpdir}/${n}/nonlin1_inverse_NL.xfm -r ${tmpdir}/${n}/t1.mnc -o ${tmpdir}/${n}/SegmentationPrior2.mnc ${N4_VERBOSE:+--verbose} -d 3 -n Linear
antsApplyTransforms -i ${CSFPRIOR} -t [ ${tmpdir}/${n}/mni0_GenericAffine.xfm,1 ] -t ${tmpdir}/${n}/nonlin1_inverse_NL.xfm -r ${tmpdir}/${n}/t1.mnc -o ${tmpdir}/${n}/SegmentationPrior1.mnc ${N4_VERBOSE:+--verbose} -d 3 -n Linear

#Masks
antsApplyTransforms -i ${REGISTRATIONBRAINMASK} -t [ ${tmpdir}/${n}/mni0_GenericAffine.xfm,1 ] -t ${tmpdir}/${n}/nonlin1_inverse_NL.xfm -r ${tmpdir}/${n}/t1.mnc -o ${tmpdir}/${n}/mnimask.mnc ${N4_VERBOSE:+--verbose} -d 3 -n GenericLabel
minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -unsigned -byte -expression '(A[0]>0.5||A[1]>0.5)?1:0' ${tmpdir}/${n}/SegmentationPrior3.mnc ${tmpdir}/${n}/SegmentationPrior2.mnc ${tmpdir}/${n}/mniprobmask.mnc
iMath 3 ${tmpdir}/${n}/mniprobmask.mnc MD ${tmpdir}/${n}/mniprobmask.mnc 3 1 ball 1
ImageMath 3 ${tmpdir}/${n}/mniprobmask.mnc FillHoles ${tmpdir}/${n}/mniprobmask.mnc 2
iMath 3 ${tmpdir}/${n}/mniprobmask.mnc ME ${tmpdir}/${n}/mniprobmask.mnc 1 1 ball 1


#Last time we generate MNI mask, save it outside iterations
cp -f ${tmpdir}/${n}/mniprobmask.mnc ${tmpdir}/mnimask.mnc
cp -f ${tmpdir}/${n}/mniaffinemask.mnc ${tmpdir}/mniaffinemask.mnc

#Combine the masks because sometimes beast misses badly biased cerebellum
mincmath -quiet ${N4_VERBOSE:+-verbose} -unsigned -labels -byte -or ${tmpdir}/${n}/mniprobmask.mnc ${tmpdir}/${n}/bmask.mnc ${tmpdir}/${n}/mask.mnc

#Expand the mask a bit
iMath 3 ${tmpdir}/${n}/mask_D.mnc MD ${tmpdir}/${n}/mask.mnc 1 1 ball 1

if [[ -n ${excludemask} ]]; then
  ImageMath 3 ${tmpdir}/${n}/mask_D.mnc m ${tmpdir}/${n}/mask_D.mnc ${excludemask}
fi

#Do an initial classification using the MNI priors
Atropos ${N4_VERBOSE:+--verbose} -d 3 -x ${tmpdir}/${n}/mask_D.mnc -c [ 25,0.001 ] -a ${tmpdir}/${n}/t1.mnc \
  -i PriorProbabilityImages[ 3,${tmpdir}/${n}/SegmentationPrior%d.mnc,${_arg_classification_prior_weight} ] -k HistogramParzenWindows -m [ 0.1,1x1x1 ] \
  -o [ ${tmpdir}/${n}/classify.mnc,${tmpdir}/${n}/SegmentationPosteriors%d.mnc ] -r 1 -p Aristotle[ 0 ] --winsorize-outliers BoxPlot \
  -l [ 0.69314718055994530942,1 ]

#Convert classification to the mask
classify_to_mask

#Vote a mask
ImageMath 3 ${tmpdir}/${n}/mask2.mnc MajorityVoting ${tmpdir}/${n}/mniaffinemask.mnc ${tmpdir}/${n}/classifymask.mnc ${tmpdir}/${n}/bmask.mnc ${tmpdir}/${n}/mniprobmask.mnc

#Generate outlier mask from white matter mask intensity
ImageMath 3 ${tmpdir}/${n}/class3.mnc m ${tmpdir}/${n}/class3.mnc ${tmpdir}/${n}/mask2.mnc
ImageMath 3 ${tmpdir}/${n}/class3.mnc GetLargestComponent ${tmpdir}/${n}/class3.mnc
outlier_mask ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/class3.mnc ${tmpdir}/${n}/hotmask.mnc

#Combine GM and WM proabability images into a N4 mask,
ImageMath 3 ${tmpdir}/${n}/weight.mnc PureTissueN4WeightMask ${tmpdir}/${n}/SegmentationPosteriors2.mnc ${tmpdir}/${n}/SegmentationPosteriors3.mnc
ImageMath 3 ${tmpdir}/${n}/weight.mnc RescaleImage ${tmpdir}/${n}/weight.mnc 0 1

ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/hotmask.mnc

if [[ -n ${excludemask} ]]; then
  ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${excludemask}
fi

#Clip the classification outputs with the new mask
for item in ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/classify.mnc ${tmpdir}/${n}/SegmentationPosteriors1.mnc ${tmpdir}/${n}/SegmentationPosteriors2.mnc ${tmpdir}/${n}/SegmentationPosteriors3.mnc; do
  ImageMath 3 ${item} m ${item} ${tmpdir}/${n}/mask2.mnc
  ImageMath 3 ${item} m ${item} ${tmpdir}/${n}/hotmask.mnc
done

ImageMath 3 ${tmpdir}/${n}/mask2_nooutlier.mnc m ${tmpdir}/${n}/mask2.mnc ${tmpdir}/${n}/hotmask.mnc

#Always exclude 0 from correction
minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -unsigned -byte -expression 'A[0]>1.01?1:0' ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/nonzero.mnc
ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/nonzero.mnc

do_N4_correct ${tmpdir}/${n}/t1.mnc ${tmpdir}/initmask.mnc ${tmpdir}/${n}/mask2_nooutlier.mnc ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/corrected.mnc ${tmpdir}/${n}/bias.mnc 4 ${tmpdir}/${n}/class3.mnc

minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -zero -expression 'A[0]/A[1]' ${tmpdir}/$((n - 1))/iterative_bias.mnc ${tmpdir}/${n}/iterative_bias.mnc ${tmpdir}/${n}/ratio.mnc
python -c "print(float(\"$(mincstats -quiet -mask ${tmpdir}/${n}/mask2.mnc -mask_binvalue 1 -stddev ${tmpdir}/${n}/ratio.mnc)\") / float(\"$(mincstats -quiet -mask ${tmpdir}/${n}/mask2.mnc -mask_binvalue 1 -mean ${tmpdir}/${n}/ratio.mnc)\"))" >>${tmpdir}/convergence.txt

if [[ ${_arg_debug} == "off" ]]; then
  rm -rf ${tmpdir}/$((n - 1))
fi

################################################################################
#Remaining rounds, N4 with segmentation posteriors bootstrapped from prior run
################################################################################
while true; do
  ((++n))
  mkdir -p ${tmpdir}/${n}

  minc_anlm ${N4_VERBOSE:+--verbose} --mt ${ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS} ${tmpdir}/$((n - 1))/corrected.mnc ${tmpdir}/${n}/t1.mnc

  #Combine the masks because sometimes beast misses badly biased cerebellum
  cp -f ${tmpdir}/$((n - 1))/mask2.mnc ${tmpdir}/${n}/mask.mnc
  iMath 3 ${tmpdir}/${n}/mask_D.mnc MD ${tmpdir}/${n}/mask.mnc 1 1 ball 1

  if [[ -n ${excludemask} ]]; then
    ImageMath 3 ${tmpdir}/${n}/mask_D.mnc m ${tmpdir}/${n}/mask_D.mnc ${excludemask}
  fi

  #Do an initial classification using the last round posteriors, remove outliers
  Atropos ${N4_VERBOSE:+--verbose} -d 3 -x ${tmpdir}/${n}/mask_D.mnc -c [ 5,0.001 ] -a ${tmpdir}/${n}/t1.mnc -s 1x2 -s 2x3 \
    -i PriorProbabilityImages[ 3,${tmpdir}/$((n - 1))/SegmentationPosteriors%d.mnc,${_arg_classification_prior_weight} ] -k HistogramParzenWindows -m [ 0.1,1x1x1 ] \
    -o [ ${tmpdir}/${n}/classify.mnc,${tmpdir}/${n}/SegmentationPosteriors%d.mnc ] -r 1 -p Aristotle[ 1 ] --winsorize-outliers BoxPlot \
    -l [ 0.69314718055994530942,1 ]

  classify_to_mask
  ImageMath 3 ${tmpdir}/${n}/mask2.mnc MajorityVoting ${tmpdir}/${n}/mask.mnc ${tmpdir}/mnimask.mnc ${tmpdir}/bmask.mnc ${tmpdir}/$((n - 1))/classifymask.mnc ${tmpdir}/${n}/classifymask.mnc
  ImageMath 3 ${tmpdir}/${n}/class3.mnc m ${tmpdir}/${n}/class3.mnc ${tmpdir}/${n}/mask2.mnc
  ImageMath 3 ${tmpdir}/${n}/class3.mnc GetLargestComponent ${tmpdir}/${n}/class3.mnc
  outlier_mask ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/class3.mnc ${tmpdir}/${n}/hotmask.mnc

  #Combine GM and WM probably images into a N4 mask,
  ImageMath 3 ${tmpdir}/${n}/weight.mnc PureTissueN4WeightMask ${tmpdir}/${n}/SegmentationPosteriors2.mnc ${tmpdir}/${n}/SegmentationPosteriors3.mnc
  ImageMath 3 ${tmpdir}/${n}/weight.mnc RescaleImage ${tmpdir}/${n}/weight.mnc 0 1

  ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/hotmask.mnc

  if [[ -n ${excludemask} ]]; then
    ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${excludemask}
  fi

  #Clip the classification weight and posteriors
  for item in ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/classify.mnc ${tmpdir}/${n}/SegmentationPosteriors1.mnc ${tmpdir}/${n}/SegmentationPosteriors2.mnc ${tmpdir}/${n}/SegmentationPosteriors3.mnc; do
    ImageMath 3 ${item} m ${item} ${tmpdir}/${n}/mask2.mnc
    ImageMath 3 ${item} m ${item} ${tmpdir}/${n}/hotmask.mnc
  done

  #Always exclude 0 from correction
  minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -unsigned -byte -expression 'A[0]>1.01?1:0' ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/nonzero.mnc
  ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/nonzero.mnc

  ImageMath 3 ${tmpdir}/${n}/mask2_nooutlier.mnc m ${tmpdir}/${n}/mask2.mnc ${tmpdir}/${n}/hotmask.mnc

  do_N4_correct ${tmpdir}/${n}/t1.mnc ${tmpdir}/initmask.mnc ${tmpdir}/${n}/mask2_nooutlier.mnc ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/corrected.mnc ${tmpdir}/${n}/bias.mnc 2 ${tmpdir}/${n}/class3.mnc

  #Compute coeffcient of variation
  minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -zero -expression 'A[0]/A[1]' ${tmpdir}/$((n - 1))/iterative_bias.mnc ${tmpdir}/${n}/iterative_bias.mnc ${tmpdir}/${n}/ratio.mnc
  python -c "print(float(\"$(mincstats -quiet -mask ${tmpdir}/${n}/mask2.mnc -mask_binvalue 1 -stddev ${tmpdir}/${n}/ratio.mnc)\") / float(\"$(mincstats -quiet -mask ${tmpdir}/${n}/mask2.mnc -mask_binvalue 1 -mean ${tmpdir}/${n}/ratio.mnc)\"))" >>${tmpdir}/convergence.txt

  if [[ ${_arg_debug} == "off" ]]; then
    rm -rf ${tmpdir}/$((n - 1))
  fi

  # Break if greater than iterations or less than convergence threshold
  [[ (${n} -lt ${_arg_max_iterations}) && ($(python -c "print($(tail -1 ${tmpdir}/convergence.txt) > ${_arg_convergence_threshold})") == "True") ]] || break

done

echo "--------------------"
echo "Convergence results:"
cat ${tmpdir}/convergence.txt
echo "--------------------"

#If cropping is enabled, recrop the originput file and resample the mask again
if [[ ${_arg_autocrop} == "on" ]]; then
  ImageMath 3 ${originput} PadImage ${originput} 50
  antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -i ${tmpdir}/headmask.mnc -o ${tmpdir}/finalheadmask.mnc -r ${originput} -n GenericLabel
  ImageMath 3 ${originput} m ${originput} ${tmpdir}/finalheadmask.mnc
  ExtractRegionFromImageByMask 3 ${originput} ${tmpdir}/originput.crop.mnc ${tmpdir}/finalheadmask.mnc 1 10
  mv -f ${tmpdir}/originput.crop.mnc ${originput}
fi

#Transform all the working files into the original input space
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -i ${tmpdir}/${n}/mask2.mnc -o ${tmpdir}/finalmask.mnc -r ${originput} -n GenericLabel
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -i ${tmpdir}/${n}/classifymask.mnc -o ${tmpdir}/finalclassifymask.mnc -r ${originput} -n GenericLabel
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -i ${tmpdir}/bmask.mnc -o ${tmpdir}/finalbmask.mnc -r ${originput} -n GenericLabel
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -i ${tmpdir}/mnimask.mnc -o ${tmpdir}/finalmnimask.mnc -r ${originput} -n GenericLabel
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -i ${tmpdir}/${n}/classify.mnc -o ${tmpdir}/finalclassify.mnc -r ${originput} -n GenericLabel
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 -i ${tmpdir}/${n}/class3.mnc -o ${tmpdir}/finalclass3.mnc -r ${originput} -n GenericLabel

#Create a FOV mask for the original input
minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -unsigned -byte -expression '1' ${originput} ${tmpdir}/originitmask.mnc

#Resample the average bias field into the original space
mincresample -clobber -quiet ${N4_VERBOSE:+-verbose} -like ${originput} -keep ${tmpdir}/${n}/iterative_bias.mnc ${tmpdir}/iterative_bias_final.mnc
mincresample -clobber -quiet ${N4_VERBOSE:+-verbose} -like ${originput} -keep ${tmpdir}/wholebrain_bias.mnc ${tmpdir}/wholebrain_bias_final.mnc

#Do the final correction
iMath 3 ${tmpdir}/finalmask_D.mnc MD ${tmpdir}/finalmask.mnc 1 1 ball 1
mincresample -clobber -quiet ${N4_VERBOSE:+-verbose} -keep -labels -near -like ${originput} ${tmpdir}/finalmask_D.mnc ${tmpdir}/finalmask_D_resample.mnc
mv -f ${tmpdir}/finalmask_D_resample.mnc ${tmpdir}/finalmask_D.mnc
ImageMath 3 ${tmpdir}/iterative_bias_apply_final.mnc m ${tmpdir}/iterative_bias_final.mnc ${tmpdir}/finalmask_D.mnc
minccalc -quiet ${N4_VERBOSE:+-verbose} -unsigned -double -expression "A[0]/$(mincstats -quiet -mean -mask ${tmpdir}/finalmask_D.mnc -mask_binvalue 0 ${tmpdir}/wholebrain_bias_final.mnc)" ${tmpdir}/wholebrain_bias_final.mnc ${tmpdir}/wholebrain_bias_apply_final.mnc
ImageMath 3 ${tmpdir}/iterative_bias_apply_final.mnc addtozero ${tmpdir}/iterative_bias_apply_final.mnc ${tmpdir}/wholebrain_bias_apply_final.mnc
ImageMath 3 ${tmpdir}/iterative_bias_apply_final.mnc addtozero ${tmpdir}/iterative_bias_apply_final.mnc 1

ImageMath 3 ${tmpdir}/corrected.mnc / ${originput} ${tmpdir}/iterative_bias_apply_final.mnc

mincresample -clobber -quiet ${N4_VERBOSE:+-verbose} -keep -labels -near -like ${tmpdir}/corrected.mnc ${tmpdir}/finalclass3.mnc ${tmpdir}/finalclass3_resample.mnc
mv -f ${tmpdir}/finalclass3_resample.mnc ${tmpdir}/finalclass3.mnc

#Normalize and rescale intensity
n4brainmean=$(mincstats -quiet -mean -mask ${tmpdir}/finalclass3.mnc -mask_binvalue 1 ${tmpdir}/corrected.mnc)
n4nonbrainmean=$(mincstats -quiet -floor 10 -mean -mask ${tmpdir}/finalmask_D.mnc -mask_binvalue 0 ${tmpdir}/corrected.mnc)
minccalc -quiet ${N4_VERBOSE:+-verbose} -short -unsigned -expression "A[1]>0?clamp(32767*A[0]/${n4brainmean},0,65535):clamp(16384*A[0]/${n4nonbrainmean},0,65535)" \
  ${tmpdir}/corrected.mnc ${tmpdir}/finalmask_D.mnc ${tmpdir}/corrected.norm.mnc

#Denoise output if requested
if [[ ${_arg_denoise} == "on" ]]; then
  minc_anlm ${N4_VERBOSE:+--verbose} --mt ${ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS} ${tmpdir}/corrected.norm.mnc ${tmpdir}/corrected.norm.denoise.mnc
  mincreshape -quiet ${N4_VERBOSE:+-verbose} -clobber -short -unsigned ${tmpdir}/corrected.norm.denoise.mnc ${output}
else
  cp -f ${tmpdir}/corrected.norm.mnc ${output}
fi

#Output final classification files if standalone
if [[ ${_arg_standalone} == "on" || ${_arg_debug} == "on" ]]; then
  mincreshape -quiet ${N4_VERBOSE:+-verbose} -clobber -byte -unsigned ${tmpdir}/finalbmask.mnc $(dirname ${output})/$(basename ${output} .mnc).beastmask.mnc
  mincreshape -quiet ${N4_VERBOSE:+-verbose} -clobber -byte -unsigned ${tmpdir}/finalmnimask.mnc $(dirname ${output})/$(basename ${output} .mnc).mnimask.mnc
  mincreshape -quiet ${N4_VERBOSE:+-verbose} -clobber -byte -unsigned ${tmpdir}/finalclassify.mnc $(dirname $output)/$(basename ${output} .mnc).classify.mnc
  mincreshape -quiet ${N4_VERBOSE:+-verbose} -clobber -byte -unsigned ${tmpdir}/finalmask.mnc $(dirname $output)/$(basename ${output} .mnc).mask.mnc
  mincreshape -quiet ${N4_VERBOSE:+-verbose} -clobber -byte -unsigned ${tmpdir}/finalclassifymask.mnc $(dirname $output)/$(basename ${output} .mnc).classifymask.mnc
  minccalc -quiet ${N4_VERBOSE:+-verbose} -clobber -short -unsigned -expression 'A[0]*A[1]' ${output} ${tmpdir}/finalmask.mnc ${tmpdir}/output.extracted.mnc
  ExtractRegionFromImageByMask 3 ${tmpdir}/output.extracted.mnc ${tmpdir}/output.extracted.crop.mnc ${tmpdir}/finalmask.mnc 1 10
  mincreshape -quiet ${N4_VERBOSE:+-verbose} -clobber -short -unsigned ${tmpdir}/output.extracted.crop.mnc $(dirname $output)/$(basename ${output} .mnc).extracted.mnc
fi

if [[ ${_arg_debug} == "off" ]]; then
  rm -rf ${tmpdir}
fi

# ] <-- needed because of Argbash
