#!/bin/bash

# Created by argbash-init v2.8.0
# Rearrange the order of options below according to what you would like to see in the help message.
# ARG_OPTIONAL_SINGLE([exclude],[e],[Mask file defining regions to exclude from classifcation, region is still corrected])
# ARG_OPTIONAL_SINGLE([t2],[],[T2w scan, will be rigidly registered to T1w and used for classification])
# ARG_OPTIONAL_SINGLE([pd],[],[PDw scan, will be rigidly registered to T1w and used for classification])
# ARG_OPTIONAL_SINGLE([config],[c],[Path to an alternative config file defining priors to use])
# ARG_OPTIONAL_SINGLE([logfile],[l],[Path to file to log all output])
# ARG_OPTIONAL_BOOLEAN([standalone],[s],[Script is run standalone so save all outputs])
# ARG_OPTIONAL_SINGLE([max-iterations],[],[Maximum number of iterations to run],[10])
# ARG_OPTIONAL_SINGLE([convergence-threshold],[],[Coeffcient of variation limit between two bias field estimates],[0.005])
# ARG_OPTIONAL_SINGLE([classification-prior-weight],[],[How much weight is given to prior classification proabilities during iteration],[0.25])
# ARG_OPTIONAL_BOOLEAN([debug],[d],[Debug mode, increase verbosity further, don't cleanup])
# ARG_VERBOSE([v])
# ARG_POSITIONAL_SINGLE([input],[T1w scan to be corrected])
# ARG_POSITIONAL_SINGLE([output],[Output filename for corrected T1w (also used as basename for other outputs)])
# ARGBASH_SET_INDENT([  ])
# ARGBASH_SET_DELIM([ =])
# ARG_OPTION_STACKING([getopt])
# ARG_RESTRICT_VALUES([no-local-options])
# ARG_DEFAULTS_POS([])
# ARG_HELP([iterativeN4_multispectral.sh is script which performs iterative inhomogeneity (bias field) correction and classification on T1w (and optionally T2w/PDw) MRI scans])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.8.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
  local _ret=$2
  test -n "$_ret" || _ret=1
  test "$_PRINT_HELP" = yes && print_help >&2
  echo "$1" >&2
  exit ${_ret}
}


evaluate_strictness()
{
  [[ "$2" =~ ^-(-(exclude|t2|pd|config|logfile|standalone|max-iterations|convergence-threshold|classification-prior-weight|debug|verbose|input|output|help)$|[eclsdvh]) ]] && die "You have passed '$2' as a value of argument '$1', which makes it look like that you have omitted the actual value, since '$2' is an option accepted by this script. This is considered a fatal error."
}


begins_with_short_option()
{
  local first_option all_short_options='eclsdvh'
  first_option="${1:0:1}"
  test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_input=
_arg_output=
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_exclude=
_arg_t2=
_arg_pd=
_arg_config=
_arg_logfile=
_arg_standalone="off"
_arg_max_iterations="10"
_arg_convergence_threshold="0.005"
_arg_classification_prior_weight="0.25"
_arg_debug="off"
_arg_verbose=0


print_help()
{
  printf '%s\n' "iterativeN4_multispectral.sh is script which performs iterative inhomogeneity (bias field) correction and classification on T1w (and optionally T2w/PDw) MRI scans"
  printf 'Usage: %s [-e|--exclude <arg>] [--t2 <arg>] [--pd <arg>] [-c|--config <arg>] [-l|--logfile <arg>] [-s|--(no-)standalone] [--max-iterations <arg>] [--convergence-threshold <arg>] [--classification-prior-weight <arg>] [-d|--(no-)debug] [-v|--verbose] [-h|--help] <input> <output>\n' "$0"
  printf '\t%s\n' "<input>: T1w scan to be corrected"
  printf '\t%s\n' "<output>: Output filename for corrected T1w (also used as basename for other outputs)"
  printf '\t%s\n' "-e, --exclude: Mask file defining regions to exclude from classifcation, region is still corrected (no default)"
  printf '\t%s\n' "--t2: T2w scan, will be rigidly registered to T1w and used for classification (no default)"
  printf '\t%s\n' "--pd: PDw scan, will be rigidly registered to T1w and used for classification (no default)"
  printf '\t%s\n' "-c, --config: Path to an alternative config file defining priors to use (no default)"
  printf '\t%s\n' "-l, --logfile: Path to file to log all output (no default)"
  printf '\t%s\n' "-s, --standalone, --no-standalone: Script is run standalone so save all outputs (off by default)"
  printf '\t%s\n' "--max-iterations: Maximum number of iterations to run (default: '10')"
  printf '\t%s\n' "--convergence-threshold: Coeffcient of variation limit between two bias field estimates (default: '0.005')"
  printf '\t%s\n' "--classification-prior-weight: How much weight is given to prior classification proabilities during iteration (default: '0.25')"
  printf '\t%s\n' "-d, --debug, --no-debug: Debug mode, increase verbosity further, don't cleanup (off by default)"
  printf '\t%s\n' "-v, --verbose: Set verbose output (can be specified multiple times to increase the effect)"
  printf '\t%s\n' "-h, --help: Prints help"
}


parse_commandline()
{
  _positionals_count=0
  while test $# -gt 0
  do
    _key="$1"
    case "$_key" in
      -e|--exclude)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_exclude="$2"
        shift
        evaluate_strictness "$_key" "$_arg_exclude"
        ;;
      --exclude=*)
        _arg_exclude="${_key##--exclude=}"
        evaluate_strictness "$_key" "$_arg_exclude"
        ;;
      -e*)
        _arg_exclude="${_key##-e}"
        evaluate_strictness "$_key" "$_arg_exclude"
        ;;
      --t2)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_t2="$2"
        shift
        evaluate_strictness "$_key" "$_arg_t2"
        ;;
      --t2=*)
        _arg_t2="${_key##--t2=}"
        evaluate_strictness "$_key" "$_arg_t2"
        ;;
      --pd)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_pd="$2"
        shift
        evaluate_strictness "$_key" "$_arg_pd"
        ;;
      --pd=*)
        _arg_pd="${_key##--pd=}"
        evaluate_strictness "$_key" "$_arg_pd"
        ;;
      -c|--config)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_config="$2"
        shift
        evaluate_strictness "$_key" "$_arg_config"
        ;;
      --config=*)
        _arg_config="${_key##--config=}"
        evaluate_strictness "$_key" "$_arg_config"
        ;;
      -c*)
        _arg_config="${_key##-c}"
        evaluate_strictness "$_key" "$_arg_config"
        ;;
      -l|--logfile)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_logfile="$2"
        shift
        evaluate_strictness "$_key" "$_arg_logfile"
        ;;
      --logfile=*)
        _arg_logfile="${_key##--logfile=}"
        evaluate_strictness "$_key" "$_arg_logfile"
        ;;
      -l*)
        _arg_logfile="${_key##-l}"
        evaluate_strictness "$_key" "$_arg_logfile"
        ;;
      -s|--no-standalone|--standalone)
        _arg_standalone="on"
        test "${1:0:5}" = "--no-" && _arg_standalone="off"
        ;;
      -s*)
        _arg_standalone="on"
        _next="${_key##-s}"
        if test -n "$_next" -a "$_next" != "$_key"
        then
          begins_with_short_option "$_next" && shift && set -- "-s" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      --max-iterations)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_max_iterations="$2"
        shift
        evaluate_strictness "$_key" "$_arg_max_iterations"
        ;;
      --max-iterations=*)
        _arg_max_iterations="${_key##--max-iterations=}"
        evaluate_strictness "$_key" "$_arg_max_iterations"
        ;;
      --convergence-threshold)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_convergence_threshold="$2"
        shift
        evaluate_strictness "$_key" "$_arg_convergence_threshold"
        ;;
      --convergence-threshold=*)
        _arg_convergence_threshold="${_key##--convergence-threshold=}"
        evaluate_strictness "$_key" "$_arg_convergence_threshold"
        ;;
      --classification-prior-weight)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_classification_prior_weight="$2"
        shift
        evaluate_strictness "$_key" "$_arg_classification_prior_weight"
        ;;
      --classification-prior-weight=*)
        _arg_classification_prior_weight="${_key##--classification-prior-weight=}"
        evaluate_strictness "$_key" "$_arg_classification_prior_weight"
        ;;
      -d|--no-debug|--debug)
        _arg_debug="on"
        test "${1:0:5}" = "--no-" && _arg_debug="off"
        ;;
      -d*)
        _arg_debug="on"
        _next="${_key##-d}"
        if test -n "$_next" -a "$_next" != "$_key"
        then
          begins_with_short_option "$_next" && shift && set -- "-d" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      -v|--verbose)
        _arg_verbose=$((_arg_verbose + 1))
        ;;
      -v*)
        _arg_verbose=$((_arg_verbose + 1))
        _next="${_key##-v}"
        if test -n "$_next" -a "$_next" != "$_key"
        then
          begins_with_short_option "$_next" && shift && set -- "-v" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      -h|--help)
        print_help
        exit 0
        ;;
      -h*)
        print_help
        exit 0
        ;;
      *)
        _last_positional="$1"
        _positionals+=("$_last_positional")
        _positionals_count=$((_positionals_count + 1))
        ;;
    esac
    shift
  done
}


handle_passed_args_count()
{
  local _required_args_string="'input' and 'output'"
  test "${_positionals_count}" -ge 2 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 2 (namely: $_required_args_string), but got only ${_positionals_count}." 1
  test "${_positionals_count}" -le 2 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
  local _positional_name _shift_for=$1
  _positional_names="_arg_input _arg_output "

  shift "$_shift_for"
  for _positional_name in ${_positional_names}
  do
    test $# -gt 0 || break
    eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
    shift
  done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

#Handle spaces properly, turn on failure modes
IFS=$'\n\t'
set -euo pipefail

if [[ -n ${_arg_logfile} ]]; then
  exec >  >(tee -ia ${_arg_logfile})
  exec 2> >(tee -ia ${_arg_logfile} >&2)
fi

#If debug, print timestamps and every command run
if [[ ${_arg_debug} == "on" ]]; then
  set -xT
  PS4='+\t '
fi

#If verbose (or debug) turn on verbose outputs for commands
if [[ ${_arg_verbose} -ge 1 || ${_arg_debug} == "on" ]]; then
  N4_VERBOSE=1
fi

tmpdir=$(mktemp -d)

#Setup exit trap for cleanup, don't do if debug
function finish {
  if [[ ${_arg_debug} == "off" ]]; then
    rm -rf "${tmpdir}"
  fi

}
trap finish EXIT


#Set local parallelism inherited from QBATCH
export ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS=${THREADS_PER_COMMAND:-$(nproc)}
export ITK_USE_THREADPOOL=1
export ITK_GLOBAL_DEFAULT_THREADER=Pool

### DEFAULT PRIORS ###

#BeAST configuration
BEASTLIBRARY_DIR="${QUARANTINE_PATH}/resources/BEaST_libraries/combined"
BEAST_CONFIG=${BEASTLIBRARY_DIR}/default.2mm.conf
BEAST_CONFIG2=${BEASTLIBRARY_DIR}/default.1mm.conf

#mni_icbm152_nlin_sym_09c priors as default
REGISTRATIONMODEL="${QUARANTINE_PATH}/resources/mni_icbm152_nlin_sym_09c_minc2/mni_icbm152_t1_tal_nlin_sym_09c.mnc"
REGISTRATIONBRAINMASK="${QUARANTINE_PATH}/resources/mni_icbm152_nlin_sym_09c_minc2/mni_icbm152_t1_tal_nlin_sym_09c_mask.mnc"
WMPRIOR="${QUARANTINE_PATH}/resources/mni_icbm152_nlin_sym_09c_minc2/mni_icbm152_wm_tal_nlin_sym_09c.mnc"
GMPRIOR="${QUARANTINE_PATH}/resources/mni_icbm152_nlin_sym_09c_minc2/mni_icbm152_gm_tal_nlin_sym_09c.mnc"
CSFPRIOR="${QUARANTINE_PATH}/resources/mni_icbm152_nlin_sym_09c_minc2/mni_icbm152_csf_tal_nlin_sym_09c.mnc"

#Files used to define MNI space
RESAMPLEMODEL="${QUARANTINE_PATH}/resources/mni_icbm152_nlin_sym_09c_minc2/mni_icbm152_t1_tal_nlin_sym_09c.mnc"
RESAMPLEMODELBRAINMASK="${QUARANTINE_PATH}/resources/mni_icbm152_nlin_sym_09c_minc2/mni_icbm152_t1_tal_nlin_sym_09c_mask.mnc"

# Check config files, eventually argbash will do this
if [[ -n ${_arg_config} ]]; then
  if [[ -r  ${_arg_config} ]]; then
    source ${_arg_config}
  else
    echo "iterativeN4_multispectral.sh ERROR: config file does not exist or is not readable" && exit 2
  fi
fi

if [[ ! -d ${BEASTLIBRARY_DIR} ]]; then
  echo "iterativeN4_multispectral.sh ERROR: ${BEASTLIBRARY_DIR} does not exist"
fi

for prior in ${REGISTRATIONMODEL} ${REGISTRATIONBRAINMASK} ${WMPRIOR} ${GMPRIOR} ${CSFPRIOR} ${RESAMPLEMODEL} ${RESAMPLEMODELBRAINMASK} ${BEAST_CONFIG}; do
  if [[ ! -s ${prior} ]]; then
    echo "iterativeN4_multispectral.sh ERROR: File ${prior} does not exist or is zero size" && exit 3
  fi
done

#Setup internal variables
output=${_arg_output}
originput=${_arg_input}

#Internal resampled input used for processing
input=${tmpdir}/t1.mnc

#Function used to do bias field correction
function do_N4_correct {
  #input fov mask weight maxval output bias shrink
  #Do first round of masked bias field correction, use brain mask as weight
  local min
  local max
  local pct25
  local pct75
  local n
  local histbins
  min=$(mincstats -quiet -min -mask $4 -mask_range 0.0001,inf $1)
  max=$(mincstats -quiet -max -mask $4 -mask_range 0.0001,inf $1)
  n=$(mincstats -quiet -count -mask $4 -mask_range 0.0001,inf $1)
  pct25=$(mincstats -quiet -pctT 25 -hist_bins 10000 -mask $4 -mask_range 0.0001,inf $1)
  pct75=$(mincstats -quiet -pctT 75 -hist_bins 10000 -mask $4 -mask_range 0.0001,inf $1)
  histbins=$(python -c  "print( int((float(${max})-float(${min}))/(2.0 * (float(${pct75})-float(${pct25})) * float(${n})**(-1.0/3.0)) ))" )
  N4BiasFieldCorrection ${N4_VERBOSE:+--verbose} -d 3 -s $8 -w $4 -x $2 \
    -b [200] -c [300x300x300x300,1e-5] --histogram-sharpening [0.05,0.01,${histbins}] -i $1 -o [$6,$7] -r 0

  #Normalize and rescale intensity
  ImageMath 3 $6 TruncateImageIntensity $6 0.0005 0.9995 1024 $3
  ImageMath 3 $6 RescaleImage $6 0 $5
}

#Convert classify image into a mask
function classify_to_mask {
  #Breakup classification and drop try to exclude small misclassified chunks
  ThresholdImage 3 ${tmpdir}/${n}/classify.mnc ${tmpdir}/${n}/class3.mnc 3 3 1 0
  ThresholdImage 3 ${tmpdir}/${n}/classify.mnc ${tmpdir}/${n}/class2.mnc 2 2 1 0
  ThresholdImage 3 ${tmpdir}/${n}/classify.mnc ${tmpdir}/${n}/class1.mnc 1 1 1 0
  ImageMath 3 ${tmpdir}/${n}/class3.mnc GetLargestComponent ${tmpdir}/${n}/class3.mnc
  ImageMath 3 ${tmpdir}/${n}/class2.mnc GetLargestComponent ${tmpdir}/${n}/class2.mnc
  iMath 3 ${tmpdir}/${n}/class1.mnc ME ${tmpdir}/${n}/class1.mnc 1 1 box 1
  ImageMath 3 ${tmpdir}/${n}/class1.mnc GetLargestComponent ${tmpdir}/${n}/class1.mnc
  iMath 3 ${tmpdir}/${n}/class1.mnc MD ${tmpdir}/${n}/class1.mnc 1 1 ball 1

  #Reconstruct a closed mask from the classification
  ImageMath 3 ${tmpdir}/${n}/classifymask.mnc addtozero ${tmpdir}/${n}/class2.mnc ${tmpdir}/${n}/class3.mnc
  ImageMath 3 ${tmpdir}/${n}/classifymask.mnc addtozero ${tmpdir}/${n}/classifymask.mnc ${tmpdir}/${n}/class1.mnc
  iMath 3 ${tmpdir}/${n}/classifymask.mnc ME ${tmpdir}/${n}/classifymask.mnc 2 1 ball 1
  ImageMath 3 ${tmpdir}/${n}/classifymask.mnc GetLargestComponent ${tmpdir}/${n}/classifymask.mnc
  iMath 3 ${tmpdir}/${n}/classifymask.mnc MD ${tmpdir}/${n}/classifymask.mnc 3 1 ball 1
  iMath 3 ${tmpdir}/${n}/classifymask.mnc MC ${tmpdir}/${n}/classifymask.mnc 5 1 ball 1
  ImageMath 3  ${tmpdir}/${n}/classifymask.mnc m ${tmpdir}/${n}/classifymask.mnc ${tmpdir}/${n}/hotmask.mnc
  ImageMath 3 ${tmpdir}/${n}/classifymask.mnc FillHoles ${tmpdir}/${n}/classifymask.mnc 2

}

function cleanup_posteriors {
  ThresholdImage 3 ${tmpdir}/${n}/classify.mnc ${tmpdir}/${n}/class3.mnc 3 3 1 0
  ThresholdImage 3 ${tmpdir}/${n}/classify.mnc ${tmpdir}/${n}/class2.mnc 2 2 1 0
  ThresholdImage 3 ${tmpdir}/${n}/classify.mnc ${tmpdir}/${n}/class1.mnc 1 1 1 0
  for num in 1 2 3; do
    ImageMath 3 ${tmpdir}/${n}/class${num}.mnc GetLargestComponent ${tmpdir}/${n}/class${num}.mnc
    ImageMath 3 ${tmpdir}/${n}/SegmentationPosteriors${num}.mnc m ${tmpdir}/${n}/SegmentationPosteriors${num}.mnc ${tmpdir}/${n}/class${num}.mnc
    ImageMath 3 ${tmpdir}/${n}/SegmentationPosteriors${num}.mnc m ${tmpdir}/${n}/SegmentationPosteriors${num}.mnc ${tmpdir}/${n}/classifymask.mnc
  done
}

multispectral_inputs=()

#Generate list of extra Atropos inputs for multispectral segmentation
multispectral_atropos_inputs=""
if (( ${#multispectral_inputs[@]} > 0 )); then
  for file in "${multispectral_inputs[@]}"; do
    multispectral_atropos_inputs+="-a ${tmpdir}/multispectral/$(basename $file .mnc).N4.mnc "
  done
fi

#Find maximum value of scan to rescale to for final output
maxval=$(mincstats -max -quiet ${originput})

#Forceably convert to MINC2, and clamp range to avoid negative numbers
mincconvert -2 ${originput} ${tmpdir}/originput.mnc
mincmath -quiet -clamp -const2 0 ${maxval} ${tmpdir}/originput.mnc ${tmpdir}/originput.clamp.mnc
mv -f ${tmpdir}/originput.clamp.mnc ${tmpdir}/originput.mnc
originput=${tmpdir}/originput.mnc

#Isotropize, crop, clamp, and pad input volume
isostep=1
ResampleImage 3 ${originput} ${input} ${isostep}x${isostep}x${isostep} 0 4
mincmath -quiet -clamp -const2 0 ${maxval} ${input} ${tmpdir}/input.clamp.mnc
mv -f ${tmpdir}/input.clamp.mnc ${input}
ImageMath 3 ${tmpdir}/cropmask.mnc ThresholdAtMean ${input} 1
autocrop -bbox ${tmpdir}/cropmask.mnc -isoexpand 10mm ${input} ${tmpdir}/input.crop.mnc
mv -f ${tmpdir}/input.crop.mnc ${input}

#If lesion mask exists, negate it to produce a multiplicative exlcusion mask, resample to internal resolution
if [[ -n ${_arg_exclude} ]]; then
  ImageMath 3 ${tmpdir}/exclude.mnc Neg ${_arg_exclude}
  excludemask=${tmpdir}/exclude.mnc
  antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 --float 1 -i ${excludemask} -r ${input} -n GenericLabel -o ${excludemask}
else
  excludemask=""
fi

#Compute final round shink factor for N4
dx=$(mincinfo -attvalue xspace:step ${originput})
dy=$(mincinfo -attvalue yspace:step ${originput})
dz=$(mincinfo -attvalue zspace:step ${originput})
shrink_final_round=$(python -c "import math; print(max(2,int(math.ceil(2.0 / ( ( abs($dx) + abs($dy) + abs($dz) ) / 3.0)))))")

#Generate a whole-image mask to force N4 to always do correction over whole image
minccalc -quiet -unsigned -byte -expression '1' ${input} ${tmpdir}/initmask.mnc
minccalc -quiet -unsigned -byte -expression 'A[0]>0?1:0' ${input} ${tmpdir}/initweight.mnc

################################################################################
#Round 0, N4 across areas greater than 1% of mean
################################################################################
n=0

mkdir -p ${tmpdir}/${n}

ImageMath 3 ${tmpdir}/${n}/weight.mnc ThresholdAtMean ${input} 0.5

if [[ -n ${excludemask} ]]; then
  ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${excludemask}
fi

do_N4_correct ${input} ${tmpdir}/initmask.mnc ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/weight.mnc ${maxval} ${tmpdir}/${n}/corrected.mnc ${tmpdir}/${n}/bias.mnc 8

################################################################################
#Round 1, N4 across areas greater than 1% of mean, intersected with affine brainmask
################################################################################
((++n))
mkdir -p ${tmpdir}/${n}

cp -f ${tmpdir}/$((n - 1))/corrected.mnc ${tmpdir}/${n}/t1.mnc

#Correct above the 1% mean threshold
ImageMath 3 ${tmpdir}/${n}/weight.mnc ThresholdAtMean ${tmpdir}/${n}/t1.mnc 0.5

antsRegistration ${N4_VERBOSE:+--verbose} -d 3 --float 1 --minc  \
  --output [${tmpdir}/${n}/mni] \
  --use-histogram-matching 0 \
  --initial-moving-transform [${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1] \
  --transform Rigid[0.5] \
  --metric Mattes[${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1,32,None] \
  --convergence [2025x2025x2025x2025x2025,1e-6,10] \
  --shrink-factors 8x8x8x8x8 \
  --smoothing-sigmas 7.99225592362x7.49173910041x6.99114831402x6.49046645078x5.98967067114vox \
  --masks [NULL,NULL] \
  --transform Similarity[0.1] \
  --metric Mattes[${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1,32,None] \
  --convergence [2025x2025x2025x2025x2025,1e-6,10] \
  --shrink-factors 8x8x8x8x8 \
  --smoothing-sigmas 5.98967067114x5.48872979374x4.98760009911x4.48621831264x3.98448927075vox \
  --masks [NULL,NULL] \
  --transform Affine[0.1] \
  --metric Mattes[${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1,51,None] \
  --convergence [2025x2025x2025x2025x675,1e-6,10] \
  --shrink-factors 8x7x6x5x4 \
  --smoothing-sigmas 3.98448927075x3.4822628776x2.97928762436x2.47510701762x1.96879525311vox \
  --masks [${REGISTRATIONBRAINMASK},NULL]

antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 --float 1 -r ${tmpdir}/${n}/t1.mnc -t [${tmpdir}/${n}/mni0_GenericAffine.xfm,1] -i ${REGISTRATIONBRAINMASK} -o ${tmpdir}/${n}/mnimask.mnc -n GenericLabel

ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/mnimask.mnc

if [[ -n ${excludemask} ]]; then
  ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${excludemask}
fi

do_N4_correct ${input} ${tmpdir}/initmask.mnc ${tmpdir}/${n}/mnimask.mnc ${tmpdir}/${n}/weight.mnc ${maxval} ${tmpdir}/${n}/corrected.mnc ${tmpdir}/${n}/bias.mnc 6

minccalc -zero -quiet -clobber -expression 'A[0]/A[1]' ${tmpdir}/$((n - 1))/bias.mnc ${tmpdir}/${n}/bias.mnc ${tmpdir}/${n}/ratio.mnc
python -c "print(float(\"$(mincstats -quiet -stddev ${tmpdir}/${n}/ratio.mnc)\") / float(\"$(mincstats -quiet -mean ${tmpdir}/${n}/ratio.mnc)\"))" >>${tmpdir}/convergence.txt

if [[ ${_arg_debug} == "off" ]]; then
  rm -rf ${tmpdir}/$((n - 1))
fi

################################################################################
#Round 2, N4 with brain mask intersected with Otsu mask
################################################################################
((++n))
mkdir -p ${tmpdir}/${n}

cp -f ${tmpdir}/$((n - 1))/corrected.mnc ${tmpdir}/${n}/t1.mnc
minc_anlm --mt ${ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS} ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/denoise.mnc
mv -f ${tmpdir}/${n}/denoise.mnc ${tmpdir}/${n}/t1.mnc

#Register to MNI space
antsRegistration ${N4_VERBOSE:+--verbose} -d 3 --float 1 --minc  \
  --output [${tmpdir}/${n}/mni] \
  --use-histogram-matching 0 \
  --initial-moving-transform [${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1] \
  --transform Rigid[0.5] \
  --metric Mattes[${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1,32,None] \
  --convergence [2025x2025x2025x2025x2025,1e-6,10] \
  --shrink-factors 8x8x8x8x8 \
  --smoothing-sigmas 7.99225592362x7.49173910041x6.99114831402x6.49046645078x5.98967067114vox \
  --masks [NULL,NULL] \
  --transform Similarity[0.1] \
  --metric Mattes[${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1,32,None] \
  --convergence [2025x2025x2025x2025x2025,1e-6,10] \
  --shrink-factors 8x8x8x8x8 \
  --smoothing-sigmas 5.98967067114x5.48872979374x4.98760009911x4.48621831264x3.98448927075vox \
  --masks [NULL,NULL] \
  --transform Affine[0.1] \
  --metric Mattes[${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1,51,None] \
  --convergence [2025x2025x2025x2025x675,1e-6,10] \
  --shrink-factors 8x7x6x5x4 \
  --smoothing-sigmas 3.98448927075x3.4822628776x2.97928762436x2.47510701762x1.96879525311vox \
  --masks [${REGISTRATIONBRAINMASK},NULL] \
  --transform Affine[0.05] \
  --metric Mattes[${REGISTRATIONMODEL},${tmpdir}/${n}/t1.mnc,1,256,None] \
  --convergence [675x225x75x25x25,1e-6,10] \
  --shrink-factors 4x3x2x1x1 \
  --smoothing-sigmas 1.96879525311x1.45813399545x0.936031382318x0.355182697615x0vox \
  --masks [${REGISTRATIONBRAINMASK},NULL]

#Repeat with nuyl matched registration
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 --float 1 -r ${tmpdir}/${n}/t1.mnc -t [${tmpdir}/${n}/mni0_GenericAffine.xfm,1] -i ${REGISTRATIONBRAINMASK} -o ${tmpdir}/${n}/mnimask.mnc -n GenericLabel
iMath 3 ${tmpdir}/${n}/shrinkmask.mnc ME ${tmpdir}/${n}/mnimask.mnc 4 1 ball 1
minc_nuyl ${tmpdir}/${n}/t1.mnc ${RESAMPLEMODEL} ${tmpdir}/${n}/t1.nuyl.mnc --source-mask ${tmpdir}/${n}/shrinkmask.mnc --target-mask ${RESAMPLEMODELBRAINMASK} --cut-off 0 --fix_zero_padding --steps 1024

antsRegistration ${N4_VERBOSE:+--verbose} -d 3 --float 1 --minc \
  --output [${tmpdir}/${n}/mni] \
  --use-histogram-matching 0 \
  --initial-moving-transform ${tmpdir}/${n}/mni0_GenericAffine.xfm \
  --transform Affine[0.05] \
  --metric Mattes[${REGISTRATIONMODEL},${tmpdir}/${n}/t1.nuyl.mnc,1,256,None] \
  --convergence [675x225x75x25x25,1e-6,10] \
  --shrink-factors 4x3x2x1x1 \
  --smoothing-sigmas 1.96879525311x1.45813399545x0.936031382318x0.355182697615x0vox \
  --masks [${REGISTRATIONBRAINMASK},NULL]

antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 --float 1 -i ${tmpdir}/${n}/t1.mnc -t ${tmpdir}/${n}/mni0_GenericAffine.xfm -n BSpline[5] -o ${tmpdir}/${n}/mni.mnc -r ${RESAMPLEMODEL}

#BSpline[5] does weird things to intensity, clip back to positive range
mincmath -clamp -const2 0 $(mincstats -quiet -max ${tmpdir}/${n}/mni.mnc) ${tmpdir}/${n}/mni.mnc ${tmpdir}/${n}/mni.clamp.mnc
mv -f ${tmpdir}/${n}/mni.clamp.mnc ${tmpdir}/${n}/mni.mnc

#Shrink the MNI mask for the first intensity matching
rm -f ${tmpdir}/${n}/shrinkmask.mnc
iMath 3 ${tmpdir}/${n}/shrinkmask.mnc ME ${RESAMPLEMODELBRAINMASK} 4 1 ball 1

#Intensity normalize
volume_pol --order 1 --min 0 --max 100 --noclamp ${tmpdir}/${n}/mni.mnc ${RESAMPLEMODEL} --source_mask ${tmpdir}/${n}/shrinkmask.mnc --target_mask ${RESAMPLEMODELBRAINMASK} ${tmpdir}/${n}/mni.norm.mnc

#Run a quick beast to get a brain mask
mincbeast ${N4_VERBOSE:+-verbose} -clobber -fill -median -same_res -flip -conf ${BEAST_CONFIG} ${BEASTLIBRARY_DIR} ${tmpdir}/${n}/mni.norm.mnc ${tmpdir}/${n}/beastmask.mnc

#Resample beast mask and MNI mask to native space
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 --float 1 -r ${tmpdir}/${n}/t1.mnc -t [${tmpdir}/${n}/mni0_GenericAffine.xfm,1] -i ${REGISTRATIONBRAINMASK} -o ${tmpdir}/${n}/mnimask.mnc -n GenericLabel
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 --float 1 -r ${tmpdir}/${n}/t1.mnc -t [${tmpdir}/${n}/mni0_GenericAffine.xfm,1] -i ${tmpdir}/${n}/beastmask.mnc -o ${tmpdir}/${n}/bmask.mnc -n GenericLabel

#Combine the masks because sometimes beast misses badly biased cerebellum
ImageMath 3 ${tmpdir}/${n}/mask.mnc addtozero ${tmpdir}/${n}/mnimask.mnc ${tmpdir}/${n}/bmask.mnc

#Expand the mask a bit
iMath 3 ${tmpdir}/${n}/mask_D.mnc MD ${tmpdir}/${n}/mask.mnc 3 1 ball 1

#Create hotmask and exlcude hot voxels from weight
ThresholdImage 3 ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/hotmask.mnc \
  0 $(mincstats -quiet -pctT 99.95 -mask ${tmpdir}/${n}/mask_D.mnc -mask_binvalue 1 ${tmpdir}/${n}/t1.mnc) 1 0

#Exclude hotspots to avoid kmeans classifying skull as brain
ImageMath 3 ${tmpdir}/${n}/mask_D.mnc m ${tmpdir}/${n}/mask_D.mnc ${tmpdir}/${n}/hotmask.mnc

ThresholdImage 3 ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/weight.mnc Otsu 1


if [[ -n ${excludemask} ]]; then
  ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${excludemask}
fi

ImageMath 3 ${tmpdir}/${n}/primary_weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/mask_D.mnc

do_N4_correct ${input} ${tmpdir}/initmask.mnc  ${tmpdir}/${n}/mask.mnc ${tmpdir}/${n}/primary_weight.mnc ${maxval} ${tmpdir}/${n}/corrected.mnc ${tmpdir}/${n}/bias.mnc 6

#Align multispectral inputs into T1 space
if (( ${#multispectral_inputs[@]} > 0 )); then
  echo "Needs to be reimplemented"
else
  cp -f ${tmpdir}/initweight.mnc ${tmpdir}/global_exclude.mnc
fi

minccalc -zero -quiet -clobber -expression 'A[0]/A[1]' ${tmpdir}/$((n - 1))/bias.mnc ${tmpdir}/${n}/bias.mnc ${tmpdir}/${n}/ratio.mnc
python -c "print(float(\"$(mincstats -quiet -stddev ${tmpdir}/${n}/ratio.mnc)\") / float(\"$(mincstats -quiet -mean ${tmpdir}/${n}/ratio.mnc)\"))" >>${tmpdir}/convergence.txt

if [[ ${_arg_debug} == "off" ]]; then
  rm -rf ${tmpdir}/$((n - 1))
fi

################################################################################
#Round 3, N4 with nonlinearly MNI-bootstrapped WM/GM segmentation proabilities
################################################################################
((++n))
mkdir -p ${tmpdir}/${n}

cp -f ${tmpdir}/$((n - 1))/corrected.mnc ${tmpdir}/${n}/t1.mnc
minc_anlm --mt ${ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS}  ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/denoise.mnc
mv -f ${tmpdir}/${n}/denoise.mnc ${tmpdir}/${n}/t1.mnc

minc_nuyl ${tmpdir}/${n}/t1.mnc ${RESAMPLEMODEL} ${tmpdir}/${n}/t1.nuyl.mnc --source-mask ${tmpdir}/$((n - 1))/mask.mnc --target-mask ${RESAMPLEMODELBRAINMASK} --cut-off 0 --fix_zero_padding --steps 1024

#Affine register to MNI space, tweak registration
antsRegistration ${N4_VERBOSE:+--verbose} -d 3 --float 1 --minc \
  --output [${tmpdir}/${n}/mni] \
  --use-histogram-matching 0 \
  --initial-moving-transform ${tmpdir}/$((n - 1))/mni0_GenericAffine.xfm \
  --transform Affine[0.05] \
  --metric Mattes[${REGISTRATIONMODEL},${tmpdir}/${n}/t1.nuyl.mnc,1,256,None] \
  --convergence [675x225x75x25x25,1e-6,10] \
  --shrink-factors 4x3x2x1x1 \
  --smoothing-sigmas 1.96879525311x1.45813399545x0.936031382318x0.355182697615x0vox \
  --masks [${REGISTRATIONBRAINMASK},${tmpdir}/$((n - 1))/mask_D.mnc]

antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 --float 1 -i ${tmpdir}/${n}/t1.mnc -t ${tmpdir}/${n}/mni0_GenericAffine.xfm -n BSpline[5] -o ${tmpdir}/${n}/mni.mnc -r ${RESAMPLEMODEL}

mincmath -clamp -const2 0 $(mincstats -quiet -max ${tmpdir}/${n}/mni.mnc) ${tmpdir}/${n}/mni.mnc ${tmpdir}/${n}/mni.clamp.mnc
mv -f ${tmpdir}/${n}/mni.clamp.mnc ${tmpdir}/${n}/mni.mnc

#Shrink last round's beastmask for normalization
iMath 3 ${tmpdir}/${n}/shrinkmask.mnc ME ${tmpdir}/$((n - 1))/beastmask.mnc 5 1 ball 1

#Intensity normalize
volume_pol --order 1 --min 0 --max 100 --noclamp ${tmpdir}/${n}/mni.mnc ${RESAMPLEMODEL} --source_mask ${tmpdir}/${n}/shrinkmask.mnc --target_mask ${RESAMPLEMODELBRAINMASK} ${tmpdir}/${n}/mni.norm.mnc

#Run a quick beast to get a brain mask
mincbeast ${N4_VERBOSE:+-verbose} -clobber -fill -median -same_res -flip -conf ${BEAST_CONFIG2} ${BEASTLIBRARY_DIR} ${tmpdir}/${n}/mni.norm.mnc ${tmpdir}/${n}/beastmask.mnc

antsApplyTransforms -i ${tmpdir}/${n}/beastmask.mnc -t [${tmpdir}/${n}/mni0_GenericAffine.xfm,1] -r ${tmpdir}/${n}/t1.mnc -o ${tmpdir}/${n}/bmask.mnc ${N4_VERBOSE:+--verbose} -d 3 -n GenericLabel
antsApplyTransforms -i ${REGISTRATIONBRAINMASK} -t [${tmpdir}/${n}/mni0_GenericAffine.xfm,1] -r ${tmpdir}/${n}/t1.mnc -o ${tmpdir}/${n}/mniaffinemask.mnc ${N4_VERBOSE:+--verbose} -d 3 -n GenericLabel
cp -f ${tmpdir}/${n}/bmask.mnc ${tmpdir}/bmask.mnc

iMath 3 ${tmpdir}/${n}/nonlinregmask.mnc MD ${tmpdir}/${n}/bmask.mnc 1 1 ball 1

#Non linearly register priors
antsRegistration ${N4_VERBOSE:+--verbose} -d 3 --float 1 --minc \
  --output [${tmpdir}/${n}/nonlin] \
  --initial-moving-transform ${tmpdir}/${n}/mni0_GenericAffine.xfm \
  --use-histogram-matching 0 \
  --transform SyN[0.1,3,0] --metric CC[${REGISTRATIONMODEL},${tmpdir}/${n}/t1.nuyl.mnc,1,4,None] \
  --convergence [2025x2025x2025x2025x2025x2025x2025x2025x2025x2025x2025x2025x2025x2025x2025x2025x2025x2025x2025x2025x2025x2025x2025x2025x2025x0,1e-6,10] \
  --shrink-factors 8x8x8x8x8x8x8x8x8x8x8x8x8x8x8x8x8x8x8x8x8x8x8x8x8x1 \
  --smoothing-sigmas 15.9961293677x15.4960044769x14.9958712567x14.495728845x13.9955762564x13.4954123593x12.9952358481x12.4950452079x11.9948386712x11.4946141627x10.9943692292x10.49410095x9.99380581904x9.49347959121x8.99311707634x8.49271186069x7.99225592362x7.49173910041x6.99114831402x6.49046645078x5.98967067114x5.48872979374x4.98760009911x4.48621831264x3.98448927075x0vox \
  --masks [NULL,NULL] \
  --transform SyN[0.1,3,0] --metric CC[${REGISTRATIONMODEL},${tmpdir}/${n}/t1.nuyl.mnc,1,2,None] \
  --convergence [2025x2025x2025x2025x675x225x75x0,1e-6,10] \
  --shrink-factors 8x7x6x5x4x3x2x1 \
  --smoothing-sigmas 3.98448927075x3.4822628776x2.97928762436x2.47510701762x1.96879525311x1.45813399545x0.936031382318x0vox \
  --masks [${REGISTRATIONBRAINMASK},NULL]

#Resample MNI Priors to Native space for classification
antsApplyTransforms -i ${WMPRIOR} -t [${tmpdir}/${n}/mni0_GenericAffine.xfm,1] -t ${tmpdir}/${n}/nonlin1_inverse_NL.xfm -r ${tmpdir}/${n}/t1.mnc -o ${tmpdir}/${n}/SegmentationPrior3.mnc ${N4_VERBOSE:+--verbose} -d 3 -n Linear
antsApplyTransforms -i ${GMPRIOR} -t [${tmpdir}/${n}/mni0_GenericAffine.xfm,1] -t ${tmpdir}/${n}/nonlin1_inverse_NL.xfm -r ${tmpdir}/${n}/t1.mnc -o ${tmpdir}/${n}/SegmentationPrior2.mnc ${N4_VERBOSE:+--verbose} -d 3 -n Linear
antsApplyTransforms -i ${CSFPRIOR} -t [${tmpdir}/${n}/mni0_GenericAffine.xfm,1] -t ${tmpdir}/${n}/nonlin1_inverse_NL.xfm -r ${tmpdir}/${n}/t1.mnc -o ${tmpdir}/${n}/SegmentationPrior1.mnc ${N4_VERBOSE:+--verbose} -d 3 -n Linear
#Masks
antsApplyTransforms -i ${REGISTRATIONBRAINMASK} -t [${tmpdir}/${n}/mni0_GenericAffine.xfm,1] -t ${tmpdir}/${n}/nonlin1_inverse_NL.xfm -r ${tmpdir}/${n}/t1.mnc -o ${tmpdir}/${n}/mnimask.mnc ${N4_VERBOSE:+--verbose} -d 3 -n GenericLabel

cp -f ${tmpdir}/${n}/mnimask.mnc ${tmpdir}/mnimask.mnc

#Combine the masks because sometimes beast misses badly biased cerebellum
ImageMath 3 ${tmpdir}/${n}/mask.mnc addtozero ${tmpdir}/${n}/mnimask.mnc ${tmpdir}/${n}/bmask.mnc

#Expand the mask a bit
iMath 3 ${tmpdir}/${n}/mask_D.mnc MD ${tmpdir}/${n}/mask.mnc 2 1 ball 1

#Create hotmask
ThresholdImage 3 ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/hotmask.mnc \
  0 $(mincstats -quiet -pctT 99.95 -mask ${tmpdir}/${n}/mask.mnc -mask_binvalue 1 ${tmpdir}/${n}/t1.mnc) 1 0

#Exclude lesions and such
ImageMath 3 ${tmpdir}/${n}/mask_D.mnc m ${tmpdir}/${n}/mask_D.mnc ${tmpdir}/global_exclude.mnc

if [[ -n ${excludemask} ]]; then
  ImageMath 3 ${tmpdir}/${n}/mask_D.mnc m ${tmpdir}/${n}/mask_D.mnc ${excludemask}
fi

#Do an initial classification using the MNI priors
Atropos ${N4_VERBOSE:+--verbose} -d 3 -x ${tmpdir}/${n}/mask_D.mnc -c [10,0] -a ${tmpdir}/${n}/t1.mnc ${multispectral_atropos_inputs} -s 1x2 -s 2x3 \
  -i PriorProbabilityImages[3,${tmpdir}/${n}/SegmentationPrior%d.mnc,${_arg_classification_prior_weight}] -k HistogramParzenWindows -m [0.1,1x1x1] \
  -o [${tmpdir}/${n}/classify.mnc,${tmpdir}/${n}/SegmentationPosteriors%d.mnc] -r 1 -p Aristotle[0] --winsorize-outliers BoxPlot -l 2[0.69314718055994530942,1] -l 3[0.69314718055994530942,1]

classify_to_mask

#Combine GM and WM proabability images into a N4 mask,
ImageMath 3 ${tmpdir}/${n}/weight.mnc PureTissueN4WeightMask ${tmpdir}/${n}/SegmentationPosteriors2.mnc ${tmpdir}/${n}/SegmentationPosteriors3.mnc
ImageMath 3 ${tmpdir}/${n}/primary_weight.mnc RescaleImage ${tmpdir}/${n}/weight.mnc 0 1

if [[ -n ${excludemask} ]]; then
  ImageMath 3 ${tmpdir}/${n}/primary_weight.mnc m ${tmpdir}/${n}/primary_weight.mnc ${excludemask}
fi

do_N4_correct ${input} ${tmpdir}/initmask.mnc  ${tmpdir}/${n}/mask.mnc ${tmpdir}/${n}/primary_weight.mnc ${maxval} ${tmpdir}/${n}/corrected.mnc ${tmpdir}/${n}/bias.mnc 4

if (( ${#multispectral_inputs[@]} > 0 )); then
  echo "Need to implement"
fi

minccalc -zero -quiet -clobber -expression 'A[0]/A[1]' ${tmpdir}/$((n - 1))/bias.mnc ${tmpdir}/${n}/bias.mnc ${tmpdir}/${n}/ratio.mnc
python -c "print(float(\"$(mincstats -quiet -stddev ${tmpdir}/${n}/ratio.mnc)\") / float(\"$(mincstats -quiet -mean ${tmpdir}/${n}/ratio.mnc)\"))" >>${tmpdir}/convergence.txt

if [[ ${_arg_debug} == "off" ]]; then
  rm -rf ${tmpdir}/$((n - 1))
fi

################################################################################
#Remaining rounds, N4 with segmentations bootstrapped from prior run
################################################################################
while true; do
  ((++n))
  mkdir -p ${tmpdir}/${n}

  cp -f ${tmpdir}/$((n - 1))/corrected.mnc ${tmpdir}/${n}/t1.mnc
  minc_anlm --mt ${ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS}  ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/denoise.mnc
  mv -f ${tmpdir}/${n}/denoise.mnc ${tmpdir}/${n}/t1.mnc

  minc_nuyl ${tmpdir}/${n}/t1.mnc ${RESAMPLEMODEL} ${tmpdir}/${n}/t1.nuyl.mnc --source-mask ${tmpdir}/$((n - 1))/mask.mnc --target-mask ${RESAMPLEMODELBRAINMASK} --cut-off 0 --fix_zero_padding --steps 1024

  #Resample beast mask and MNI mask to native space
  cp -f ${tmpdir}/mnimask.mnc ${tmpdir}/${n}/mnimask.mnc

  #Combine the masks because sometimes beast misses badly biased cerebellum
  cp -f ${tmpdir}/$((n - 1))/classifymask.mnc ${tmpdir}/${n}/mask.mnc
  iMath 3 ${tmpdir}/${n}/mask_D.mnc MD ${tmpdir}/${n}/mask.mnc 2 1 ball 1

  #Create hotmask
  ThresholdImage 3 ${tmpdir}/${n}/t1.mnc ${tmpdir}/${n}/hotmask.mnc \
    0 $(mincstats -quiet -pctT 99.95 -mask ${tmpdir}/${n}/mask_D.mnc -mask_binvalue 1 ${tmpdir}/${n}/t1.mnc) 1 0

  ImageMath 3 ${tmpdir}/${n}/mask_D.mnc m ${tmpdir}/${n}/mask_D.mnc ${tmpdir}/global_exclude.mnc

  if [[ -n ${excludemask} ]]; then
    ImageMath 3 ${tmpdir}/${n}/mask_D.mnc m ${tmpdir}/${n}/mask_D.mnc ${excludemask}
  fi

  #Do an initial classification using the last round posteriors, remove outliers
  Atropos ${N4_VERBOSE:+--verbose} -d 3 -x ${tmpdir}/${n}/mask_D.mnc -c [5,0.0] -a ${tmpdir}/${n}/t1.mnc ${multispectral_atropos_inputs} -s 1x2 -s 2x3 \
    -i PriorProbabilityImages[3,${tmpdir}/$((n - 1))/SegmentationPosteriors%d.mnc,${_arg_classification_prior_weight}] -k HistogramParzenWindows -m [0.1,1x1x1] \
    -o [${tmpdir}/${n}/classify.mnc,${tmpdir}/${n}/SegmentationPosteriors%d.mnc] -r 1 -p Aristotle[0] --winsorize-outliers BoxPlot
  classify_to_mask

  #Combine GM and WM probably images into a N4 mask,
  ImageMath 3 ${tmpdir}/${n}/weight.mnc PureTissueN4WeightMask ${tmpdir}/${n}/SegmentationPosteriors2.mnc ${tmpdir}/${n}/SegmentationPosteriors3.mnc
  ImageMath 3 ${tmpdir}/${n}/primary_weight.mnc RescaleImage ${tmpdir}/${n}/weight.mnc 0 1

  if [[ -n ${excludemask} ]]; then
    ImageMath 3 ${tmpdir}/${n}/primary_weight.mnc m ${tmpdir}/${n}/primary_weight.mnc ${excludemask}
  fi

  do_N4_correct ${input} ${tmpdir}/initmask.mnc  ${tmpdir}/${n}/mask.mnc ${tmpdir}/${n}/primary_weight.mnc ${maxval} ${tmpdir}/${n}/corrected.mnc ${tmpdir}/${n}/bias.mnc 4

  #Loop over multispectral inputs
  if (( ${#multispectral_inputs[@]} > 0 )); then
    echo "Need to implement"
  fi

  #Compute coeffcient of variation
  minccalc -zero -quiet -clobber -expression 'A[0]/A[1]' ${tmpdir}/$((n - 1))/bias.mnc ${tmpdir}/${n}/bias.mnc ${tmpdir}/${n}/ratio.mnc
  python -c "print(float(\"$(mincstats -quiet -stddev ${tmpdir}/${n}/ratio.mnc)\") / float(\"$(mincstats -quiet -mean ${tmpdir}/${n}/ratio.mnc)\"))" >>${tmpdir}/convergence.txt

  if [[ ${_arg_debug} == "off" ]]; then
    rm -rf ${tmpdir}/$((n - 1))
  fi

  # Maximum number of iterations is 10, CV difference less than 0.005
  [[ (${n} -lt ${_arg_max_iterations}) && ($(python -c "print($(tail -1 ${tmpdir}/convergence.txt) > ${_arg_convergence_threshold})") == "True") ]] || break

done

echo "Convergence results:"
cat ${tmpdir}/convergence.txt

#Transform all the working files into the original input space
mincresample -like ${originput} ${tmpdir}/${n}/primary_weight.mnc ${tmpdir}/finalweight.mnc
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 --float 1 -i ${tmpdir}/${n}/mask.mnc -o ${tmpdir}/finalmask.mnc -r ${originput} -n GenericLabel
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 --float 1 -i ${tmpdir}/bmask.mnc -o ${tmpdir}/finalbmask.mnc -r ${originput} -n GenericLabel
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 --float 1 -i ${tmpdir}/mnimask.mnc -o ${tmpdir}/finalmnimask.mnc -r ${originput} -n GenericLabel
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 --float 1 -i ${tmpdir}/${n}/classifymask.mnc -o ${tmpdir}/finalclassifymask.mnc -r ${originput} -n GenericLabel
antsApplyTransforms ${N4_VERBOSE:+--verbose} -d 3 --float 1 -i ${tmpdir}/${n}/classify.mnc -o ${tmpdir}/finalclassify.mnc -r ${originput} -n GenericLabel

#Create a FOV mask for the original input
minccalc -quiet -unsigned -byte -expression 'A[0]?1:1' ${originput} ${tmpdir}/originitmask.mnc

do_N4_correct ${originput} ${tmpdir}/originitmask.mnc ${tmpdir}/finalmask.mnc ${tmpdir}/finalweight.mnc ${maxval} ${tmpdir}/corrected.mnc ${tmpdir}/bias.mnc ${shrink_final_round}

if (( ${#multispectral_inputs[@]} > 0 )); then
  echo "Need to implement"
fi

cp -f ${tmpdir}/corrected.mnc ${output}

if [[ ${_arg_standalone} == "on" ]]; then
  cp -f ${tmpdir}/finalbmask.mnc $(dirname ${output})/$(basename ${output} .mnc).beastmask.mnc
  cp -f ${tmpdir}/finalmnimask.mnc $(dirname ${output})/$(basename ${output} .mnc).mnimask.mnc
  cp -f ${tmpdir}/finalclassifymask.mnc $(dirname $output)/$(basename ${output} .mnc).classifymask.mnc
  cp -f ${tmpdir}/finalclassify.mnc $(dirname $output)/$(basename ${output} .mnc).classify.mnc
  cp -f ${tmpdir}/finalmask.mnc $(dirname $output)/$(basename ${output} .mnc).mask.mnc
fi

if [[ ${_arg_debug} == "off" ]]; then
  rm -rf ${tmpdir}
fi

# ] <-- needed because of Argbash
